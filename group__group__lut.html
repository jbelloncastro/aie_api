<!-- SPDX-License-Identifier: MIT -->
<!-- Copyright (C) 2022 Xilinx, Inc. -->
<!-- Copyright (C) 2022-2024 Advanced Micro Devices, Inc. -->
<!-- HTML header for doxygen 1.9.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AI Engine API User Guide: Lookup Tables</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="tables.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow" style="height: 60px">
  <td id="projectlogo" style="vertical-align: middle; padding-left: 15px; padding-right: 30px"><img height="32" alt="Logo" src="amd-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">AI Engine API User Guide<span id="projectnumber">&#160;(AIE-API)           2025.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('group__group__lut.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a>  </div>
  <div class="headertitle"><div class="title">Lookup Tables</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Overview</h2>
<dl class="section note"><dt>Note</dt><dd>Lookup table functionality is only available from AIE-ML/XDNA 1</dd></dl>
<p>Two abstractions are provided to represent lookup tables on AIE architectures:</p>
<ol type="1">
<li><a class="el" href="#structaie_1_1parallel__lookup">aie::parallel_lookup</a> which provides a direct lookup</li>
<li><a class="el" href="#structaie_1_1linear__approx">aie::linear_approx</a> which provides a linear approximation for non-linear functions</li>
</ol>
<p>The primary purpose of these abstractions is to leverage hardware support for parallel accesses on certain AIE architectures.</p>
<p>Both of these abstractions are built upon the <a class="el" href="#structaie_1_1lut">aie::lut</a> type that is used to encapsulate the raw LUT data. This encapsulation is implemented in an attempt to ensure correct data layout for a given lookup type. Specifically, to achieve a given level of access parallelism, the LUT values are required to have a specific layout in memory, which is dependent on the required number of parallel loads. For details on the memory layout requirements, see the <a class="el" href="#structaie_1_1lut">aie::lut</a> documentation.</p>
<p>Example implementations of parallel lookup and linear approximation functions are given below:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Value&gt;</div>
<div class="line"><span class="keywordtype">void</span> parallel_lookup(<span class="keyword">const</span> <a class="code hl_typedef" href="types_8hpp.html#a3626f2f93183532b6e8b19234cc5c4d3">int8</a>* pIn, Value* pOut, <span class="keyword">const</span> <a class="code hl_struct" href="#structaie_1_1lut">aie::lut&lt;4, Value&gt;</a>&amp; my_lut,</div>
<div class="line">                     <span class="keywordtype">int</span> samples, <span class="keywordtype">int</span> step_bits, <span class="keywordtype">int</span> bias, <span class="keywordtype">int</span> LUT_elems)</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_struct" href="#structaie_1_1parallel__lookup">aie::parallel_lookup&lt;int8, aie::lut&lt;4, Value&gt;</a>&gt; lookup(my_lut, step_bits, bias);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> it_in  = <a class="code hl_function" href="group__group__adf.html#gadc3cd769c76c4026ea57cd0df72f81ce">aie::begin_vector&lt;32&gt;</a>(pIn);</div>
<div class="line">    <span class="keyword">auto</span> it_out = <a class="code hl_function" href="group__group__adf.html#gadc3cd769c76c4026ea57cd0df72f81ce">aie::begin_vector&lt;32&gt;</a>(pOut);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> l = 0; l &lt; samples / 32; ++l)</div>
<div class="line">        *it_out++ = lookup.fetch(*it_in++);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> OffsetType, <span class="keyword">typename</span> SlopeType&gt;</div>
<div class="line"><span class="keywordtype">void</span> linear_approx(<span class="keyword">const</span> <a class="code hl_typedef" href="types_8hpp.html#a3626f2f93183532b6e8b19234cc5c4d3">int8</a>* pIn, OffsetType* pOut, <span class="keyword">const</span> <a class="code hl_struct" href="#structaie_1_1lut">aie::lut&lt;4, OffsetType, SlopeType&gt;</a>&amp; my_lut,</div>
<div class="line">                   <span class="keywordtype">int</span> samples, <span class="keywordtype">int</span> step_bits, <span class="keywordtype">int</span> bias, <span class="keywordtype">int</span> LUT_elems, <span class="keywordtype">int</span> shift_offset, <span class="keywordtype">int</span> shift_out)</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_struct" href="#structaie_1_1linear__approx">aie::linear_approx&lt;int8, aie::lut&lt;4, OffsetType, SlopeType&gt;</a>&gt; lin_approx(my_lut, step_bits, bias, shift_offset);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> it_in  = <a class="code hl_function" href="group__group__adf.html#gadc3cd769c76c4026ea57cd0df72f81ce">aie::begin_vector&lt;32&gt;</a>(pIn);</div>
<div class="line">    <span class="keyword">auto</span> it_out = <a class="code hl_function" href="group__group__adf.html#gadc3cd769c76c4026ea57cd0df72f81ce">aie::begin_vector&lt;32&gt;</a>(pOut);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> l = 0; l &lt; samples / 32; ++l)</div>
<div class="line">        *it_out++ = lin_approx.compute(*it_in++).to_vector&lt;LUT_T&gt;(shift_out);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__group__adf_html_gadc3cd769c76c4026ea57cd0df72f81ce"><div class="ttname"><a href="group__group__adf.html#gadc3cd769c76c4026ea57cd0df72f81ce">aie::begin_vector</a></div><div class="ttdeci">constexpr auto begin_vector(adf::io_buffer&lt; T, Dir, Config &gt; &amp;port)</div><div class="ttdoc">Returns a vector iterator over given io buffer.</div><div class="ttdef"><b>Definition</b> io_buffer.hpp:242</div></div>
<div class="ttc" id="agroup__group__lut_html_structaie_1_1linear__approx"><div class="ttname"><a href="#structaie_1_1linear__approx">aie::linear_approx</a></div><div class="ttdef"><b>Definition</b> aie.hpp:6426</div></div>
<div class="ttc" id="agroup__group__lut_html_structaie_1_1lut"><div class="ttname"><a href="#structaie_1_1lut">aie::lut</a></div><div class="ttdoc">Abstraction to represent a LUT that is stored in memory, instantiated with pointer(s) to the already ...</div><div class="ttdef"><b>Definition</b> aie.hpp:6284</div></div>
<div class="ttc" id="agroup__group__lut_html_structaie_1_1parallel__lookup"><div class="ttname"><a href="#structaie_1_1parallel__lookup">aie::parallel_lookup</a></div><div class="ttdef"><b>Definition</b> aie.hpp:6478</div></div>
<div class="ttc" id="atypes_8hpp_html_a3626f2f93183532b6e8b19234cc5c4d3"><div class="ttname"><a href="types_8hpp.html#a3626f2f93183532b6e8b19234cc5c4d3">int8</a></div><div class="ttdeci">int8_t int8</div><div class="ttdef"><b>Definition</b> types.hpp:20</div></div>
</div><!-- fragment --> <table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:structaie_1_1linear__approx" id="r_structaie_1_1linear__approx"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#structaie_1_1linear__approx">aie::linear_approx&lt; T, MyLUT &gt;</a></td></tr>
<tr class="separator:structaie_1_1linear__approx"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structaie_1_1lut" id="r_structaie_1_1lut"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#structaie_1_1lut">aie::lut&lt; ParallelAccesses, OffsetType, SlopeType &gt;</a></td></tr>
<tr class="memdesc:structaie_1_1lut"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstraction to represent a LUT that is stored in memory, instantiated with pointer(s) to the already appropriately populated memory and the number of elements.  <a href="#structaie_1_1lut">More...</a><br /></td></tr>
<tr class="separator:structaie_1_1lut"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structaie_1_1parallel__lookup" id="r_structaie_1_1parallel__lookup"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#structaie_1_1parallel__lookup">aie::parallel_lookup&lt; T, MyLUT, oor_policy &gt;</a></td></tr>
<tr class="separator:structaie_1_1parallel__lookup"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Class Documentation</h2>
<a name="structaie_1_1linear__approx" id="structaie_1_1linear__approx"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structaie_1_1linear__approx">&#9670;&#160;</a></span>aie::linear_approx</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct aie::linear_approx</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T, ParallelLUT MyLUT&gt;<br />
requires (<a class="el" href="group__group__utility__functions.html#a625fe645add467b5e19e60195bcc971a">arch::is</a>(<a class="el" href="group__group__utility__functions.html#ac2cdece807dd8a3785a30a968bf89892aa82d89a380c790b126450e584e106179">arch::Gen2</a>))<br />
struct aie::linear_approx&lt; T, MyLUT &gt;</div><dl class="section note"><dt>Note</dt><dd>Linear approximation functionality is only available from AIE-ML/XDNA 1</dd></dl>
<p>Type to support a linear approximation via interpolation with slope/offset values stored in a lookup table.</p>
<p>The offset values are simply the samples of the function to be approximated. The slope values, which are the slopes of the function at the corresponding sample, are used in conjunction with the input to more accurately estimate the function value between sample points.</p>
<p>The logical steps of the computation for an integer based linear approximation are:</p><ul>
<li>index = (input &gt;&gt; step_bits) + bias</li>
<li>slope/offset pair read from LUT based on index</li>
<li>output = slope * (input &amp; ((1 &lt;&lt; step_bits) - 1)) + (offset &lt;&lt; shift_offset)</li>
</ul>
<p>while the steps for a floating point based approximation are:</p><ul>
<li>index = (int(floor(input)) &gt;&gt; step_bits) + bias</li>
<li>slope/offset pair read from LUT based on index</li>
<li>output = slope * input + offset</li>
</ul>
<p>Note that for integer based linear approximations, the slope is multiplied by an integer value in the range [0, 1 &lt;&lt; step_bits) and therefore tweaking of the LUT values or <a class="el" href="#structaie_1_1linear__approx">linear_approx</a> parameters may be required to ensure that offset[i] + slope[i] * ((1 &lt;&lt; step_bits) - 1) approximately equals offset[i+1].</p>
<p>The slope and offset values are expected to be placed adjacent in memory. The number of achieved lookups per cycle is determined by the <a class="el" href="#structaie_1_1lut">aie::lut</a> object that encapsulates the contents of the lookup table. The following example shows the memory layout of a 128b bank width lookup table with 16b values and slopes, which achieves 4 lookups per cycle:</p>
<div class="fragment"><div class="line"><span class="keyword">constexpr</span> <span class="keywordtype">unsigned</span> size = 8;</div>
<div class="line"><span class="keyword">alignas</span>(<a class="code hl_variable" href="group__group__memory.html#gac0cd7fb3077c2394beef755dc918ba17">aie::vector_decl_align</a>) <span class="keyword">const</span> <a class="code hl_typedef" href="types_8hpp.html#aa918a75369e273ba410b034cd2ced87b">int16</a> lut_ab[size*2*2] = {slope0, offset0, slope1, offset1, slope2, offset2, slope3, offset3,</div>
<div class="line">                                                                slope0, offset0, slope1, offset1, slope2, offset2, slope3, offset3, <span class="comment">//note 128b duplication</span></div>
<div class="line">                                                                slope4, offset4, slope5, offset5, slope6, offset6, slope7, offset7,</div>
<div class="line">                                                                slope4, offset4, slope5, offset5, slope6, offset6, slope7, offset7};</div>
<div class="line"><span class="keyword">alignas</span>(<a class="code hl_variable" href="group__group__memory.html#gac0cd7fb3077c2394beef755dc918ba17">aie::vector_decl_align</a>) <span class="keyword">const</span> <a class="code hl_typedef" href="types_8hpp.html#aa918a75369e273ba410b034cd2ced87b">int16</a> lut_cd[size*2*2] = {slope0, offset0, slope1, offset1, slope2, offset2, slope3, offset3,</div>
<div class="line">                                                                slope0, offset0, slope1, offset1, slope2, offset2, slope3, offset3,</div>
<div class="line">                                                                slope4, offset4, slope5, offset5, slope6, offset6, slope7, offset7,</div>
<div class="line">                                                                slope4, offset4, slope5, offset5, slope6, offset6, slope7, offset7};</div>
<div class="line"><a class="code hl_struct" href="#structaie_1_1lut">aie::lut&lt;4, int16, int16&gt;</a> lookup_table(size, lut_ab, lut_cd);</div>
<div class="ttc" id="agroup__group__memory_html_gac0cd7fb3077c2394beef755dc918ba17"><div class="ttname"><a href="group__group__memory.html#gac0cd7fb3077c2394beef755dc918ba17">aie::vector_decl_align</a></div><div class="ttdeci">static constexpr unsigned vector_decl_align</div><div class="ttdoc">Specifies the minimum alignment requirement for vector loads and stores.</div><div class="ttdef"><b>Definition</b> aie.hpp:552</div></div>
<div class="ttc" id="atypes_8hpp_html_aa918a75369e273ba410b034cd2ced87b"><div class="ttname"><a href="types_8hpp.html#aa918a75369e273ba410b034cd2ced87b">int16</a></div><div class="ttdeci">int16_t int16</div><div class="ttdef"><b>Definition</b> types.hpp:21</div></div>
</div><!-- fragment --><table class="doxtable">
<caption>Supported linear approximation types</caption>
<tr>
<th>Input</th><th>Offset</th><th>Slope</th><th>Accumulator type</th><th>Lanes</th><th>Minumum step_bits required </th></tr>
<tr>
<td><a class="el" href="types_8hpp.html#a3626f2f93183532b6e8b19234cc5c4d3">int8</a></td><td><a class="el" href="types_8hpp.html#a3626f2f93183532b6e8b19234cc5c4d3">int8</a> </td><td><a class="el" href="types_8hpp.html#a3626f2f93183532b6e8b19234cc5c4d3">int8</a> </td><td><a class="el" href="group__group__basic__types__accum.html#structacc32" title="Tag used to request an accumulator with at least 32 bit per element.">acc32</a> </td><td>32 </td><td>2 </td></tr>
<tr>
<td><a class="el" href="types_8hpp.html#aa918a75369e273ba410b034cd2ced87b">int16</a></td><td><a class="el" href="types_8hpp.html#aa918a75369e273ba410b034cd2ced87b">int16</a> </td><td><a class="el" href="types_8hpp.html#aa918a75369e273ba410b034cd2ced87b">int16</a> </td><td><a class="el" href="group__group__basic__types__accum.html#structacc64" title="Tag used to request an accumulator with at least 64 bit per element.">acc64</a> </td><td>16 </td><td>3 </td></tr>
<tr>
<td><a class="el" href="types_8hpp.html#aa918a75369e273ba410b034cd2ced87b">int16</a></td><td><a class="el" href="types_8hpp.html#a3271a6f688eb2ba4047a2982ff49919a">int32</a> </td><td><a class="el" href="types_8hpp.html#a3271a6f688eb2ba4047a2982ff49919a">int32</a> </td><td><a class="el" href="group__group__basic__types__accum.html#structacc64" title="Tag used to request an accumulator with at least 64 bit per element.">acc64</a> </td><td>16 </td><td>4 </td></tr>
<tr>
<td><a class="el" href="types_8hpp.html#structbfloat16">bfloat16</a></td><td>float</td><td><a class="el" href="types_8hpp.html#structbfloat16">bfloat16</a> </td><td>accfloat </td><td>16 </td><td>0 </td></tr>
</table>
<p>Note that while the floating point linear approx requires the offset data to be 32b floats, the slope data is required to be <a class="el" href="types_8hpp.html#structbfloat16">bfloat16</a>. However, it is required that all values in the LUT be 32b to ensure the LUT is correctly aligned. While it is safe to use floats as the storage type for the lookup table, it is required that the low 16 mantissa bits of the floating point slope value be zero.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the input vector, containing values used to index the lookup table. </td></tr>
    <tr><td class="paramname">MyLUT</td><td>Definition of the LUT type, using the <a class="el" href="group__group__lut.html">lut</a> type. </td></tr>
  </table>
  </dd>
</dl>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Public Member Functions</h3></td></tr>
<tr class="memitem:ae63d4936af10a2f38aefeba54e1b30d4" id="r_ae63d4936af10a2f38aefeba54e1b30d4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae63d4936af10a2f38aefeba54e1b30d4">linear_approx</a> (const MyLUT &amp;l, unsigned step_bits, int bias=0, int shift_offset=0)</td></tr>
<tr class="memdesc:ae63d4936af10a2f38aefeba54e1b30d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor, configures aspects of how the approximation is performed.  <br /></td></tr>
<tr class="separator:ae63d4936af10a2f38aefeba54e1b30d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22df6d38d5fe00d65456f1bb6e4e86a7" id="r_a22df6d38d5fe00d65456f1bb6e4e86a7"><td class="memTemplParams" colspan="2">template&lt;Vector Vec&gt; </td></tr>
<tr class="memitem:a22df6d38d5fe00d65456f1bb6e4e86a7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a22df6d38d5fe00d65456f1bb6e4e86a7">compute</a> (const Vec &amp;input)</td></tr>
<tr class="memdesc:a22df6d38d5fe00d65456f1bb6e4e86a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a linear approximation for the input values with the configured lookup table.  <br /></td></tr>
<tr class="separator:a22df6d38d5fe00d65456f1bb6e4e86a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Constructor &amp; Destructor Documentation</h4>
<a id="ae63d4936af10a2f38aefeba54e1b30d4" name="ae63d4936af10a2f38aefeba54e1b30d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae63d4936af10a2f38aefeba54e1b30d4">&#9670;&#160;</a></span>linear_approx()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, ParallelLUT MyLUT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#structaie_1_1linear__approx">aie::linear_approx</a>&lt; T, MyLUT &gt;::linear_approx </td>
          <td>(</td>
          <td class="paramtype">const MyLUT &amp;</td>          <td class="paramname"><span class="paramname"><em>l</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>step_bits</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>bias</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>shift_offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor, configures aspects of how the approximation is performed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>LUT containing the stored slope/offset value pairs used for the linear approximation. Each value in the LUT has the slope in the LSB, the offset in the MSB. </td></tr>
    <tr><td class="paramname">step_bits</td><td>Lower bits that won't be used from the input to index the LUT. For integer input, these will be the remainder multiplied by the slope value at each point. For float values, the input values are used directly in the multiplication </td></tr>
    <tr><td class="paramname">bias</td><td>Optional offset added to the input values used to index, for example to center on 0 by adding half the number of LUT elements. </td></tr>
    <tr><td class="paramname">shift_offset</td><td>Optional scaling factor applied to the offset before adding it (to avoid loss of precision). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h4 class="groupheader">Member Function Documentation</h4>
<a id="a22df6d38d5fe00d65456f1bb6e4e86a7" name="a22df6d38d5fe00d65456f1bb6e4e86a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22df6d38d5fe00d65456f1bb6e4e86a7">&#9670;&#160;</a></span>compute()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, ParallelLUT MyLUT&gt; </div>
<div class="memtemplate">
template&lt;Vector Vec&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="#structaie_1_1linear__approx">aie::linear_approx</a>&lt; T, MyLUT &gt;::compute </td>
          <td>(</td>
          <td class="paramtype">const Vec &amp;</td>          <td class="paramname"><span class="paramname"><em>input</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a linear approximation for the input values with the configured lookup table. </p>
<p>An accumulator of the same number of elements as the input is returned. <br  />
Input values are interpreted from MSB to LSB: headroom | LUT elements | step_bits</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td><a class="el" href="conceptaie_1_1Vector.html">Vector</a> of input values that are used to index the look-up table. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>

</div>
</div>
<a name="structaie_1_1lut" id="structaie_1_1lut"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structaie_1_1lut">&#9670;&#160;</a></span>aie::lut</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct aie::lut</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><div class="compoundTemplParams">template&lt;unsigned ParallelAccesses, typename OffsetType, typename SlopeType = OffsetType&gt;<br />
requires (<a class="el" href="group__group__utility__functions.html#a625fe645add467b5e19e60195bcc971a">arch::is</a>(<a class="el" href="group__group__utility__functions.html#ac2cdece807dd8a3785a30a968bf89892aa82d89a380c790b126450e584e106179">arch::Gen2</a>))<br />
struct aie::lut&lt; ParallelAccesses, OffsetType, SlopeType &gt;</div><p>Abstraction to represent a LUT that is stored in memory, instantiated with pointer(s) to the already appropriately populated memory and the number of elements. </p>
<p>The requirement on memory layout is that for degree N parallel accesses, N copies of the LUT data are required; i.e.</p>
<ul>
<li>For a single load without parallelism, the values required to be stored linearly in memory.</li>
<li>For 2 loads in parallel, the LUT needs to have 2 copies of the LUT values with repetition every bank width. For example with 32b values and a 128b bank width, in memory we would have the first 4 values (128b), then the same 4 again, then the next 4, which then repeat, etc.</li>
<li>For 4 loads in parallel, we require the same layout as for 2 loads, but two distinct copies in this layout, placed in different memory banks.</li>
</ul>
<p>Currently the only supported implementation on this architecture is for 4 parallel accesses.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ParallelAccesses</td><td>Defines how many parallel accesses will be done in a single LUT access, possibilities depend on the hardware available for the given architecture </td></tr>
    <tr><td class="paramname">OffsetType</td><td>Type of values stored within the lookup table. </td></tr>
    <tr><td class="paramname">SlopeType</td><td>Optional template parameter, only needed in certain cases of linear approximation where the offset/slope value pair uses two different types. </td></tr>
  </table>
  </dd>
</dl>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Public Types</h3></td></tr>
<tr class="memitem:aa330b3cc4e41bfd9b75aaec7de132b5d" id="r_aa330b3cc4e41bfd9b75aaec7de132b5d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa330b3cc4e41bfd9b75aaec7de132b5d">lut_impl</a> = detail::lut&lt;ParallelAccesses, OffsetType, SlopeType&gt;</td></tr>
<tr class="separator:aa330b3cc4e41bfd9b75aaec7de132b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52f91f63652cd58766cd752267033758" id="r_a52f91f63652cd58766cd752267033758"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a52f91f63652cd58766cd752267033758">offset_type</a> = OffsetType</td></tr>
<tr class="separator:a52f91f63652cd58766cd752267033758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4647a30b124c775fa19c442c5580294" id="r_aa4647a30b124c775fa19c442c5580294"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa4647a30b124c775fa19c442c5580294">slope_type</a> = SlopeType</td></tr>
<tr class="separator:aa4647a30b124c775fa19c442c5580294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Public Member Functions</h3></td></tr>
<tr class="memitem:ae2d7e85fac9184ff3d09146721093ced" id="r_ae2d7e85fac9184ff3d09146721093ced"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae2d7e85fac9184ff3d09146721093ced">lut</a> (unsigned LUT_elems, const void *LUT_a)</td></tr>
<tr class="memdesc:ae2d7e85fac9184ff3d09146721093ced"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for singular access.  <br /></td></tr>
<tr class="separator:ae2d7e85fac9184ff3d09146721093ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a198c9aa3c67df680e060f7c7564e666b" id="r_a198c9aa3c67df680e060f7c7564e666b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a198c9aa3c67df680e060f7c7564e666b">lut</a> (unsigned LUT_elems, const void *LUT_ab)</td></tr>
<tr class="memdesc:a198c9aa3c67df680e060f7c7564e666b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for two parallel accesses.  <br /></td></tr>
<tr class="separator:a198c9aa3c67df680e060f7c7564e666b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab93ab437afe868dcf9bc06247d0ee74c" id="r_ab93ab437afe868dcf9bc06247d0ee74c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab93ab437afe868dcf9bc06247d0ee74c">lut</a> (unsigned LUT_elems, const void *LUT_ab, const void *LUT_cd)</td></tr>
<tr class="memdesc:ab93ab437afe868dcf9bc06247d0ee74c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for 4 parallel accesses.  <br /></td></tr>
<tr class="separator:ab93ab437afe868dcf9bc06247d0ee74c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Member Typedef Documentation</h4>
<a id="aa330b3cc4e41bfd9b75aaec7de132b5d" name="aa330b3cc4e41bfd9b75aaec7de132b5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa330b3cc4e41bfd9b75aaec7de132b5d">&#9670;&#160;</a></span>lut_impl</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned ParallelAccesses, typename OffsetType, typename SlopeType = OffsetType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#structaie_1_1lut">aie::lut</a>&lt; ParallelAccesses, OffsetType, SlopeType &gt;::lut_impl = detail::lut&lt;ParallelAccesses, OffsetType, SlopeType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a52f91f63652cd58766cd752267033758" name="a52f91f63652cd58766cd752267033758"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52f91f63652cd58766cd752267033758">&#9670;&#160;</a></span>offset_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned ParallelAccesses, typename OffsetType, typename SlopeType = OffsetType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#structaie_1_1lut">aie::lut</a>&lt; ParallelAccesses, OffsetType, SlopeType &gt;::offset_type = OffsetType</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa4647a30b124c775fa19c442c5580294" name="aa4647a30b124c775fa19c442c5580294"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4647a30b124c775fa19c442c5580294">&#9670;&#160;</a></span>slope_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned ParallelAccesses, typename OffsetType, typename SlopeType = OffsetType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#structaie_1_1lut">aie::lut</a>&lt; ParallelAccesses, OffsetType, SlopeType &gt;::slope_type = SlopeType</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h4 class="groupheader">Constructor &amp; Destructor Documentation</h4>
<a id="ab93ab437afe868dcf9bc06247d0ee74c" name="ab93ab437afe868dcf9bc06247d0ee74c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab93ab437afe868dcf9bc06247d0ee74c">&#9670;&#160;</a></span>lut() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned ParallelAccesses, typename OffsetType, typename SlopeType = OffsetType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#structaie_1_1lut">aie::lut</a>&lt; ParallelAccesses, OffsetType, SlopeType &gt;::lut </td>
          <td>(</td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>LUT_elems</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>LUT_ab</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>LUT_cd</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for 4 parallel accesses. </p>
<p>Each pointer points to an equivalent LUT populated within which the values are repeated twice, interleaved at a bank width granularity. In total the same values need to be present 4 times in memory to allow for the 4 parallel accesses.</p>
<p>For example, with a 128b bank width:</p>
<div class="fragment"><div class="line"><span class="keyword">constexpr</span> <span class="keywordtype">unsigned</span> size = 8;</div>
<div class="line"><span class="keyword">alignas</span>(<a class="code hl_variable" href="group__group__memory.html#gac0cd7fb3077c2394beef755dc918ba17">aie::vector_decl_align</a>) <span class="keyword">const</span> <a class="code hl_typedef" href="types_8hpp.html#a3271a6f688eb2ba4047a2982ff49919a">int32</a> lut_ab[size*2] = {value0, value1, value2, value3,</div>
<div class="line">                                                              value0, value1, value2, value3, <span class="comment">//note 128b duplication</span></div>
<div class="line">                                                              value4, value5, value6, value7,</div>
<div class="line">                                                              value4, value5, value6, value7};</div>
<div class="line"><span class="keyword">alignas</span>(<a class="code hl_variable" href="group__group__memory.html#gac0cd7fb3077c2394beef755dc918ba17">aie::vector_decl_align</a>) <span class="keyword">const</span> <a class="code hl_typedef" href="types_8hpp.html#a3271a6f688eb2ba4047a2982ff49919a">int32</a> lut_cd[size*2] = {value0, value1, value2, value3,</div>
<div class="line">                                                              value0, value1, value2, value3,</div>
<div class="line">                                                              value4, value5, value6, value7,</div>
<div class="line">                                                              value4, value5, value6, value7};</div>
<div class="line"><a class="code hl_struct" href="#structaie_1_1lut">aie::lut&lt;4, int32&gt;</a> lookup_table(size, lut_ab, lut_cd);</div>
<div class="ttc" id="atypes_8hpp_html_a3271a6f688eb2ba4047a2982ff49919a"><div class="ttname"><a href="types_8hpp.html#a3271a6f688eb2ba4047a2982ff49919a">int32</a></div><div class="ttdeci">int32_t int32</div><div class="ttdef"><b>Definition</b> types.hpp:22</div></div>
</div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>Input table pointers must satisfy the alignment requirements of <a class="el" href="group__group__memory.html#gac0cd7fb3077c2394beef755dc918ba17">aie::vector_decl_align</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">LUT_elems</td><td>Number elements in the LUT (not accounting for repetition). </td></tr>
    <tr><td class="paramname">LUT_ab</td><td>First two copies of the data, with the values repeated and interleaved at bank width granularity. </td></tr>
    <tr><td class="paramname">LUT_cd</td><td>Next two copies of the data, with the values repeated and interleaved at bank width granularity. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a198c9aa3c67df680e060f7c7564e666b" name="a198c9aa3c67df680e060f7c7564e666b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a198c9aa3c67df680e060f7c7564e666b">&#9670;&#160;</a></span>lut() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned ParallelAccesses, typename OffsetType, typename SlopeType = OffsetType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#structaie_1_1lut">aie::lut</a>&lt; ParallelAccesses, OffsetType, SlopeType &gt;::lut </td>
          <td>(</td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>LUT_elems</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>LUT_ab</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for two parallel accesses. </p>
<p>For example, with a 128b bank width:</p>
<div class="fragment"><div class="line"><span class="keyword">constexpr</span> <span class="keywordtype">unsigned</span> size = 8;</div>
<div class="line"><span class="keyword">alignas</span>(<a class="code hl_variable" href="group__group__memory.html#gac0cd7fb3077c2394beef755dc918ba17">aie::vector_decl_align</a>) <span class="keyword">const</span> <a class="code hl_typedef" href="types_8hpp.html#a3271a6f688eb2ba4047a2982ff49919a">int32</a> lut_ab[size*2] = {value0, value1, value2, value3,</div>
<div class="line">                                                              value0, value1, value2, value3, <span class="comment">//note 128b duplication</span></div>
<div class="line">                                                              value4, value5, value6, value7,</div>
<div class="line">                                                              value4, value5, value6, value7};</div>
<div class="line"><a class="code hl_struct" href="#structaie_1_1lut">aie::lut&lt;2, int32&gt;</a> lookup_table(size, lut_ab);</div>
</div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>Input table pointers must satisfy the alignment requirements of <a class="el" href="group__group__memory.html#gac0cd7fb3077c2394beef755dc918ba17">aie::vector_decl_align</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">LUT_elems</td><td>Number of elements in the LUT (not accounting for repetition). </td></tr>
    <tr><td class="paramname">LUT_ab</td><td>Two copies of the data, with the values interleaved at bank width granularity. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae2d7e85fac9184ff3d09146721093ced" name="ae2d7e85fac9184ff3d09146721093ced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2d7e85fac9184ff3d09146721093ced">&#9670;&#160;</a></span>lut() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned ParallelAccesses, typename OffsetType, typename SlopeType = OffsetType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#structaie_1_1lut">aie::lut</a>&lt; ParallelAccesses, OffsetType, SlopeType &gt;::lut </td>
          <td>(</td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>LUT_elems</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>LUT_a</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for singular access. </p>
<p>For example,</p>
<div class="fragment"><div class="line"><span class="keyword">constexpr</span> <span class="keywordtype">unsigned</span> size = 8;</div>
<div class="line"><span class="keyword">alignas</span>(<a class="code hl_variable" href="group__group__memory.html#gac0cd7fb3077c2394beef755dc918ba17">aie::vector_decl_align</a>) <span class="keyword">const</span> <a class="code hl_typedef" href="types_8hpp.html#a3271a6f688eb2ba4047a2982ff49919a">int32</a> lut_a[size] = {value0, value1, value2, value3,</div>
<div class="line">                                                           value4, value5, value6, value7};</div>
<div class="line"><a class="code hl_struct" href="#structaie_1_1lut">aie::lut&lt;1, int32&gt;</a> lookup_table(size, lut_a);</div>
</div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>Input table pointers must satisfy the alignment requirements of <a class="el" href="group__group__memory.html#gac0cd7fb3077c2394beef755dc918ba17">aie::vector_decl_align</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">LUT_elems</td><td>Number of elements in the LUT. </td></tr>
    <tr><td class="paramname">LUT_a</td><td>Pointer to the LUT values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>

</div>
</div>
<a name="structaie_1_1parallel__lookup" id="structaie_1_1parallel__lookup"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structaie_1_1parallel__lookup">&#9670;&#160;</a></span>aie::parallel_lookup</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct aie::parallel_lookup</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T, ParallelLUT MyLUT, lut_oor_policy oor_policy = lut_oor_policy::saturate&gt;<br />
requires (<a class="el" href="group__group__utility__functions.html#a625fe645add467b5e19e60195bcc971a">arch::is</a>(<a class="el" href="group__group__utility__functions.html#ac2cdece807dd8a3785a30a968bf89892aa82d89a380c790b126450e584e106179">arch::Gen2</a>))<br />
struct aie::parallel_lookup&lt; T, MyLUT, oor_policy &gt;</div><dl class="section note"><dt>Note</dt><dd>Parallel lookup functionality is only available from AIE-ML/XDNA 1</dd></dl>
<p>Type with functionality to directly index a LUT based on input vector of values. The number of achieved lookups per cycle is determined by the <a class="el" href="#structaie_1_1lut">aie::lut</a> object that encapsulates the contents of the lookup table. Refer to <a class="el" href="#structaie_1_1lut">aie::lut</a> for more details.</p>
<p>Real signed and unsigned integer types (&gt;=8b) are supported as indices. All types (&gt;=8b) are supported as value types, including <a class="el" href="types_8hpp.html#structbfloat16">bfloat16</a>, real, and complex types. </p><dl class="section note"><dt>Note</dt><dd>8b value type lookups require the data to be stored in the lookup tables as 16b values due to the granularity of the memory accesses.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the input vector, containing values used to index the lookup table. </td></tr>
    <tr><td class="paramname">MyLUT</td><td>Definition of the LUT type, using the <a class="el" href="group__group__lut.html">lut</a> type </td></tr>
    <tr><td class="paramname">oor_policy</td><td>Defines the "out of range policy" for when index values on the input go beyond the size of the LUT. It can either saturate, taking on the min/max valid index, or truncate, retaining the lower bits for unsigned indicies or wrapping in the interval [-bias,lut_size-bias) for signed indices. Saturating is the default behaviour, but for certain non-linear functions which repeat after an interval truncation may be required. </td></tr>
  </table>
  </dd>
</dl>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Public Member Functions</h3></td></tr>
<tr class="memitem:a8a7a436f15a29db0d16dcd11d0a53156" id="r_a8a7a436f15a29db0d16dcd11d0a53156"><td class="memTemplParams" colspan="2">template&lt;typename U = T&gt; <br />
requires (std::is_unsigned_v&lt;T&gt;)</td></tr>
<tr class="memitem:a8a7a436f15a29db0d16dcd11d0a53156"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8a7a436f15a29db0d16dcd11d0a53156">parallel_lookup</a> (const MyLUT &amp;l, unsigned step_bits=0)</td></tr>
<tr class="memdesc:a8a7a436f15a29db0d16dcd11d0a53156"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for unsigned input types, configures aspects of how the lookup is performed.  <br /></td></tr>
<tr class="separator:a8a7a436f15a29db0d16dcd11d0a53156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a010172e6e8b5c6dd7ef1c0b2c3fe4849" id="r_a010172e6e8b5c6dd7ef1c0b2c3fe4849"><td class="memTemplParams" colspan="2">template&lt;typename U = T&gt; <br />
requires (std::is_signed_v&lt;T&gt;)</td></tr>
<tr class="memitem:a010172e6e8b5c6dd7ef1c0b2c3fe4849"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a010172e6e8b5c6dd7ef1c0b2c3fe4849">parallel_lookup</a> (const MyLUT &amp;l, unsigned step_bits=0, unsigned bias=0)</td></tr>
<tr class="memdesc:a010172e6e8b5c6dd7ef1c0b2c3fe4849"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for signed input types, configures aspects of how the lookup is performed.  <br /></td></tr>
<tr class="separator:a010172e6e8b5c6dd7ef1c0b2c3fe4849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad23e7bdbb866cdb1f0d3a61e395c6e38" id="r_ad23e7bdbb866cdb1f0d3a61e395c6e38"><td class="memTemplParams" colspan="2">template&lt;Vector Vec, unsigned N = Vec::size()&gt; </td></tr>
<tr class="memitem:ad23e7bdbb866cdb1f0d3a61e395c6e38"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group__basic__types.html#classaie_1_1vector">vector</a>&lt; typename MyLUT::offset_type, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad23e7bdbb866cdb1f0d3a61e395c6e38">fetch</a> (const Vec &amp;input)</td></tr>
<tr class="memdesc:ad23e7bdbb866cdb1f0d3a61e395c6e38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses the lookup table based on the provided input values, will return a vector of the same number of elements as the input vector.  <br /></td></tr>
<tr class="separator:ad23e7bdbb866cdb1f0d3a61e395c6e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad23e7bdbb866cdb1f0d3a61e395c6e38" id="r_ad23e7bdbb866cdb1f0d3a61e395c6e38"><td class="memTemplParams" colspan="2">template&lt;unsigned N, Vector Vec&gt; </td></tr>
<tr class="memitem:ad23e7bdbb866cdb1f0d3a61e395c6e38"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group__basic__types.html#classaie_1_1vector">vector</a>&lt; typename MyLUT::offset_type, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad23e7bdbb866cdb1f0d3a61e395c6e38">fetch</a> (const Vec &amp;input)</td></tr>
<tr class="memdesc:ad23e7bdbb866cdb1f0d3a61e395c6e38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses the lookup table based on the provided input values.  <br /></td></tr>
<tr class="separator:ad23e7bdbb866cdb1f0d3a61e395c6e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Constructor &amp; Destructor Documentation</h4>
<a id="a010172e6e8b5c6dd7ef1c0b2c3fe4849" name="a010172e6e8b5c6dd7ef1c0b2c3fe4849"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a010172e6e8b5c6dd7ef1c0b2c3fe4849">&#9670;&#160;</a></span>parallel_lookup() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, ParallelLUT MyLUT, lut_oor_policy oor_policy = lut_oor_policy::saturate&gt; </div>
<div class="memtemplate">
template&lt;typename U = T&gt; <br />
requires (std::is_signed_v&lt;T&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#structaie_1_1parallel__lookup">aie::parallel_lookup</a>&lt; T, MyLUT, oor_policy &gt;::parallel_lookup </td>
          <td>(</td>
          <td class="paramtype">const MyLUT &amp;</td>          <td class="paramname"><span class="paramname"><em>l</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>step_bits</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>bias</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for signed input types, configures aspects of how the lookup is performed. </p>
<p>Note that usage of step_bits requires either:</p><ul>
<li>The rounding mode is set to the default <code><a class="el" href="namespaceaie.html#a2f5a93422bf82f6144037f0c37071119a7515875808ef6219fa6fd725e2105588" title="Always round towards negative infinity.">aie::rounding_mode::floor</a></code></li>
<li>The lowest step_bits of the index are zero</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>LUT containing the stored values used for the linear approximation. </td></tr>
    <tr><td class="paramname">step_bits</td><td>Optional lower bits that will be ignored for indexing the LUT. </td></tr>
    <tr><td class="paramname">bias</td><td>Optional offset added to the input values used to index, for example to center on 0 by adding half the number of LUT elements. This value, if supplied, must be a power of 2. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8a7a436f15a29db0d16dcd11d0a53156" name="a8a7a436f15a29db0d16dcd11d0a53156"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a7a436f15a29db0d16dcd11d0a53156">&#9670;&#160;</a></span>parallel_lookup() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, ParallelLUT MyLUT, lut_oor_policy oor_policy = lut_oor_policy::saturate&gt; </div>
<div class="memtemplate">
template&lt;typename U = T&gt; <br />
requires (std::is_unsigned_v&lt;T&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#structaie_1_1parallel__lookup">aie::parallel_lookup</a>&lt; T, MyLUT, oor_policy &gt;::parallel_lookup </td>
          <td>(</td>
          <td class="paramtype">const MyLUT &amp;</td>          <td class="paramname"><span class="paramname"><em>l</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>step_bits</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for unsigned input types, configures aspects of how the lookup is performed. </p>
<p>Note that usage of step_bits requires either:</p><ul>
<li>The rounding mode is set to the default <code><a class="el" href="namespaceaie.html#a2f5a93422bf82f6144037f0c37071119a7515875808ef6219fa6fd725e2105588" title="Always round towards negative infinity.">aie::rounding_mode::floor</a></code></li>
<li>The lowest step_bits of the index are zero</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>LUT containing the stored values used for the linear approximation. </td></tr>
    <tr><td class="paramname">step_bits</td><td>Optional lower bits that will be ignored for indexing the LUT. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h4 class="groupheader">Member Function Documentation</h4>
<a id="ad23e7bdbb866cdb1f0d3a61e395c6e38" name="ad23e7bdbb866cdb1f0d3a61e395c6e38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad23e7bdbb866cdb1f0d3a61e395c6e38">&#9670;&#160;</a></span>fetch() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, ParallelLUT MyLUT, lut_oor_policy oor_policy = lut_oor_policy::saturate&gt; </div>
<div class="memtemplate">
template&lt;Vector Vec, unsigned N = Vec::size()&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__basic__types.html#classaie_1_1vector">vector</a>&lt; typename MyLUT::offset_type, N &gt; <a class="el" href="#structaie_1_1parallel__lookup">aie::parallel_lookup</a>&lt; T, MyLUT, oor_policy &gt;::fetch </td>
          <td>(</td>
          <td class="paramtype">const Vec &amp;</td>          <td class="paramname"><span class="paramname"><em>input</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accesses the lookup table based on the provided input values, will return a vector of the same number of elements as the input vector. </p>
<p><br  />
Input values are interpreted from MSB to LSB: headroom | LUT elements | step_bits</p>
<p>Note the step_bits are required to be zeroed if the rounding mode is set to anything other than <code><a class="el" href="namespaceaie.html#a2f5a93422bf82f6144037f0c37071119a7515875808ef6219fa6fd725e2105588" title="Always round towards negative infinity.">aie::rounding_mode::floor</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td><a class="el" href="conceptaie_1_1Vector.html">Vector</a> of input values that are used to index the look-up table. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad23e7bdbb866cdb1f0d3a61e395c6e38" name="ad23e7bdbb866cdb1f0d3a61e395c6e38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad23e7bdbb866cdb1f0d3a61e395c6e38">&#9670;&#160;</a></span>fetch() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, ParallelLUT MyLUT, lut_oor_policy oor_policy = lut_oor_policy::saturate&gt; </div>
<div class="memtemplate">
template&lt;unsigned N, Vector Vec&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__basic__types.html#classaie_1_1vector">vector</a>&lt; typename MyLUT::offset_type, N &gt; <a class="el" href="#structaie_1_1parallel__lookup">aie::parallel_lookup</a>&lt; T, MyLUT, oor_policy &gt;::fetch </td>
          <td>(</td>
          <td class="paramtype">const Vec &amp;</td>          <td class="paramname"><span class="paramname"><em>input</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accesses the lookup table based on the provided input values. </p>
<p>This overload allows the size of the returned vector to be specified as a template parameter. This may be required when mapping small index types to large value types as a direct mapping may not be valid. For example, mapping <code><a class="el" href="types_8hpp.html#a3626f2f93183532b6e8b19234cc5c4d3">int8</a></code> to <code>cint32</code> on a given architecture may require <code>input</code> to be 16 elements. <code>fetch(input)</code> would therefore deduce a return type of <code><a class="el" href="group__group__basic__types.html#classaie_1_1vector" title="Type for vector registers.">aie::vector</a>&lt;cint32, 16&gt;</code>, which may be unsupported. However, returning <code><a class="el" href="group__group__basic__types.html#classaie_1_1vector" title="Type for vector registers.">aie::vector</a>&lt;cint32, 8&gt;</code> by calling <code>fetch&lt;8&gt;(input)</code> may be valid. <br  />
Input values are interpreted from MSB to LSB: headroom | LUT elements | step_bits</p>
<p>Note the step_bits are required to be zeroed if the rounding mode is set to anything other than <code><a class="el" href="namespaceaie.html#a2f5a93422bf82f6144037f0c37071119a7515875808ef6219fa6fd725e2105588" title="Always round towards negative infinity.">aie::rounding_mode::floor</a></code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>The number of elements to lookup, which may be less than the input vector size </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td><a class="el" href="conceptaie_1_1Vector.html">Vector</a> of input values that are used to index the look-up table. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- SPDX-License-Identifier: MIT -->
<!-- Copyright (C) 2022 Xilinx, Inc. -->
<!-- Copyright (C) 2022-2024 Advanced Micro Devices, Inc. -->
<!-- HTML footer for doxygen 1.9.0-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">UG1529 &copy; 2024 Advanced Micro Devices, Inc. All rights reserved.</li>
  </ul>
</div>
</body>
</html>
