<!-- SPDX-License-Identifier: MIT -->
<!-- Copyright (C) 2022 Xilinx, Inc. -->
<!-- Copyright (C) 2022-2024 Advanced Micro Devices, Inc. -->
<!-- HTML header for doxygen 1.9.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AI Engine API User Guide: Reshaping</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="tables.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow" style="height: 60px">
  <td id="projectlogo" style="vertical-align: middle; padding-left: 15px; padding-right: 30px"><img height="32" alt="Logo" src="amd-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">AI Engine API User Guide<span id="projectnumber">&#160;(AIE-API)           2025.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('group__group__reshape.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Reshaping</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Overview</h2>
<p>AIE API provides operations to change the location of the elements within a vector and to combine the elements from two or more vectors. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:classaie_1_1filter__mode" id="r_classaie_1_1filter__mode"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#classaie_1_1filter__mode">aie::filter_mode&lt; T, Elems &gt;</a></td></tr>
<tr class="memdesc:classaie_1_1filter__mode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables precomputation of the filter element selection.  <a href="#classaie_1_1filter__mode">More...</a><br /></td></tr>
<tr class="separator:classaie_1_1filter__mode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classaie_1_1interleave__unzip__mode" id="r_classaie_1_1interleave__unzip__mode"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#classaie_1_1interleave__unzip__mode">aie::interleave_unzip_mode&lt; T, Elems &gt;</a></td></tr>
<tr class="memdesc:classaie_1_1interleave__unzip__mode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables precomputation of the interleave element selection.  <a href="#classaie_1_1interleave__unzip__mode">More...</a><br /></td></tr>
<tr class="separator:classaie_1_1interleave__unzip__mode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classaie_1_1interleave__zip__mode" id="r_classaie_1_1interleave__zip__mode"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#classaie_1_1interleave__zip__mode">aie::interleave_zip_mode&lt; T, Elems &gt;</a></td></tr>
<tr class="memdesc:classaie_1_1interleave__zip__mode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables precomputation of the interleave element selection.  <a href="#classaie_1_1interleave__zip__mode">More...</a><br /></td></tr>
<tr class="separator:classaie_1_1interleave__zip__mode"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga7dfeba667f965b1270cd23c3ecab919f" id="r_ga7dfeba667f965b1270cd23c3ecab919f"><td class="memTemplParams" colspan="2">template&lt;Vector Vec, ElemBaseType T, unsigned Elems&gt; <br />
requires (std::is_same_v&lt;typename Vec::value_type, T&gt; &amp;&amp; Vec::size() == Elems)</td></tr>
<tr class="memitem:ga7dfeba667f965b1270cd23c3ecab919f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga7dfeba667f965b1270cd23c3ecab919f">aie::filter</a> (const Vec &amp;v, <a class="el" href="#classaie_1_1filter__mode">filter_mode</a>&lt; T, Elems &gt; mode) -&gt; <a class="el" href="group__group__basic__types.html#classaie_1_1vector">vector</a>&lt; T, Elems/2 &gt;</td></tr>
<tr class="memdesc:ga7dfeba667f965b1270cd23c3ecab919f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of half the size.  <br /></td></tr>
<tr class="separator:ga7dfeba667f965b1270cd23c3ecab919f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacaff9b63a0499a2549d93873f4d2516b" id="r_gacaff9b63a0499a2549d93873f4d2516b"><td class="memTemplParams" colspan="2">template&lt;Vector Vec&gt; </td></tr>
<tr class="memitem:gacaff9b63a0499a2549d93873f4d2516b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gacaff9b63a0499a2549d93873f4d2516b">aie::filter_even</a> (const Vec &amp;v, unsigned chunk_size=1) -&gt; <a class="el" href="group__group__basic__types.html#classaie_1_1vector">vector</a>&lt; typename Vec::value_type, Vec::size()/2 &gt;</td></tr>
<tr class="memdesc:gacaff9b63a0499a2549d93873f4d2516b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of half the size whose contents follow the following pattern.  <br /></td></tr>
<tr class="separator:gacaff9b63a0499a2549d93873f4d2516b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae30977ff03f577797bd8afe4ec12ca0b" id="r_gae30977ff03f577797bd8afe4ec12ca0b"><td class="memTemplParams" colspan="2">template&lt;Vector Vec&gt; </td></tr>
<tr class="memitem:gae30977ff03f577797bd8afe4ec12ca0b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gae30977ff03f577797bd8afe4ec12ca0b">aie::filter_odd</a> (const Vec &amp;v, unsigned chunk_size=1) -&gt; <a class="el" href="group__group__basic__types.html#classaie_1_1vector">vector</a>&lt; typename Vec::value_type, Vec::size()/2 &gt;</td></tr>
<tr class="memdesc:gae30977ff03f577797bd8afe4ec12ca0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of half the size whose contents follow the following pattern.  <br /></td></tr>
<tr class="separator:gae30977ff03f577797bd8afe4ec12ca0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ef610fa6d4fe1fd67f93d1a7a024266" id="r_ga6ef610fa6d4fe1fd67f93d1a7a024266"><td class="memTemplParams" colspan="2">template&lt;ComplexVector Vec&gt; </td></tr>
<tr class="memitem:ga6ef610fa6d4fe1fd67f93d1a7a024266"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga6ef610fa6d4fe1fd67f93d1a7a024266">aie::imag</a> (const Vec &amp;v) -&gt; <a class="el" href="group__group__basic__types.html#classaie_1_1vector">vector</a>&lt; detail::utils::get_complex_component_type_t&lt; typename Vec::value_type &gt;, Vec::size()&gt;</td></tr>
<tr class="memdesc:ga6ef610fa6d4fe1fd67f93d1a7a024266"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather and return the imaginary components of a complex vector.  <br /></td></tr>
<tr class="separator:ga6ef610fa6d4fe1fd67f93d1a7a024266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61bca811fa4b427c9a8e490763e9d334" id="r_ga61bca811fa4b427c9a8e490763e9d334"><td class="memTemplParams" colspan="2">template&lt;ComplexElem Elem&gt; </td></tr>
<tr class="memitem:ga61bca811fa4b427c9a8e490763e9d334"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga61bca811fa4b427c9a8e490763e9d334">aie::imag</a> (Elem e) -&gt; detail::utils::get_complex_component_type_t&lt; <a class="el" href="namespaceaie.html#a69f163f105f63a640ffec2eea2230f93">operand_base_type_t</a>&lt; Elem &gt; &gt;</td></tr>
<tr class="memdesc:ga61bca811fa4b427c9a8e490763e9d334"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the imaginary component of a complex value.  <br /></td></tr>
<tr class="separator:ga61bca811fa4b427c9a8e490763e9d334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87ca1c50ee0039879af94f0d267f1c6b" id="r_ga87ca1c50ee0039879af94f0d267f1c6b"><td class="memTemplParams" colspan="2">template&lt;Vector Vec1, Vector Vec2&gt; <br />
requires (<a class="el" href="namespaceaie.html#a4aeecaeb33bbf13108f02dcec54b29cb">is_same_vector_v</a>&lt;Vec1, Vec2&gt;)</td></tr>
<tr class="memitem:ga87ca1c50ee0039879af94f0d267f1c6b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga87ca1c50ee0039879af94f0d267f1c6b">aie::interleave_unzip</a> (const Vec1 &amp;v, const Vec2 &amp;w, unsigned chunk_size) -&gt; std::pair&lt; aie_dm_resource_remove_t&lt; Vec1 &gt;, aie_dm_resource_remove_t&lt; Vec1 &gt; &gt;</td></tr>
<tr class="memdesc:ga87ca1c50ee0039879af94f0d267f1c6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Picks elements sequentially from the input vectors and writes them alternatively into the output vectors.  <br /></td></tr>
<tr class="separator:ga87ca1c50ee0039879af94f0d267f1c6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49b02d5125d3adaa055c644297343b8a" id="r_ga49b02d5125d3adaa055c644297343b8a"><td class="memTemplParams" colspan="2">template&lt;Vector Vec1, Vector Vec2, ElemBaseType T, unsigned Elems&gt; <br />
requires (<a class="el" href="group__group__utility__functions.html#a625fe645add467b5e19e60195bcc971a">arch::is</a>(<a class="el" href="group__group__utility__functions.html#ac2cdece807dd8a3785a30a968bf89892aa82d89a380c790b126450e584e106179">arch::Gen2</a>) &amp;&amp; <a class="el" href="namespaceaie.html#a4aeecaeb33bbf13108f02dcec54b29cb">is_same_vector_v</a>&lt;Vec1, Vec2&gt; &amp;&amp; std::is_same_v&lt;typename Vec1::value_type, T&gt; &amp;&amp; Vec1::size() == Elems)</td></tr>
<tr class="memitem:ga49b02d5125d3adaa055c644297343b8a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga49b02d5125d3adaa055c644297343b8a">aie::interleave_unzip</a> (const Vec1 &amp;v1, const Vec2 &amp;v2, const <a class="el" href="#classaie_1_1interleave__unzip__mode">interleave_unzip_mode</a>&lt; T, Elems &gt; &amp;mode) -&gt; std::pair&lt; aie_dm_resource_remove_t&lt; Vec1 &gt;, aie_dm_resource_remove_t&lt; Vec1 &gt; &gt;</td></tr>
<tr class="memdesc:ga49b02d5125d3adaa055c644297343b8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Picks elements sequentially from the input vectors and writes them alternatively into the output vectors.  <br /></td></tr>
<tr class="separator:ga49b02d5125d3adaa055c644297343b8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39a16c9f4ab6c16d89fd3c16750cedfd" id="r_ga39a16c9f4ab6c16d89fd3c16750cedfd"><td class="memTemplParams" colspan="2">template&lt;Vector Vec1, Vector Vec2, ElemBaseType T, unsigned Elems&gt; <br />
requires (<a class="el" href="group__group__utility__functions.html#a625fe645add467b5e19e60195bcc971a">arch::is</a>(<a class="el" href="group__group__utility__functions.html#ac2cdece807dd8a3785a30a968bf89892aa82d89a380c790b126450e584e106179">arch::Gen2</a>) &amp;&amp; <a class="el" href="namespaceaie.html#a4aeecaeb33bbf13108f02dcec54b29cb">is_same_vector_v</a>&lt;Vec1, Vec2&gt; &amp;&amp; std::is_same_v&lt;typename Vec1::value_type, T&gt; &amp;&amp; Vec1::size() == Elems)</td></tr>
<tr class="memitem:ga39a16c9f4ab6c16d89fd3c16750cedfd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga39a16c9f4ab6c16d89fd3c16750cedfd">aie::interleave_zip</a> (const Vec1 &amp;v, const Vec2 &amp;w, const <a class="el" href="#classaie_1_1interleave__zip__mode">interleave_zip_mode</a>&lt; T, Elems &gt; &amp;mode) -&gt; std::pair&lt; aie_dm_resource_remove_t&lt; Vec1 &gt;, aie_dm_resource_remove_t&lt; Vec1 &gt; &gt;</td></tr>
<tr class="memdesc:ga39a16c9f4ab6c16d89fd3c16750cedfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Picks elements alternatively from the input vectors and writes them sequentially into the output vectors.  <br /></td></tr>
<tr class="separator:ga39a16c9f4ab6c16d89fd3c16750cedfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88a182aac4704b1ad640383356008524" id="r_ga88a182aac4704b1ad640383356008524"><td class="memTemplParams" colspan="2">template&lt;Vector Vec1, Vector Vec2&gt; <br />
requires (<a class="el" href="namespaceaie.html#a4aeecaeb33bbf13108f02dcec54b29cb">is_same_vector_v</a>&lt;Vec1, Vec2&gt;)</td></tr>
<tr class="memitem:ga88a182aac4704b1ad640383356008524"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga88a182aac4704b1ad640383356008524">aie::interleave_zip</a> (const Vec1 &amp;v, const Vec2 &amp;w, unsigned chunk_size) -&gt; std::pair&lt; aie_dm_resource_remove_t&lt; Vec1 &gt;, aie_dm_resource_remove_t&lt; Vec1 &gt; &gt;</td></tr>
<tr class="memdesc:ga88a182aac4704b1ad640383356008524"><td class="mdescLeft">&#160;</td><td class="mdescRight">Picks elements alternatively from the input vectors and writes them sequentially into the output vectors.  <br /></td></tr>
<tr class="separator:ga88a182aac4704b1ad640383356008524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab72e76c6970231b60f9946c52f762256" id="r_gab72e76c6970231b60f9946c52f762256"><td class="memTemplParams" colspan="2">template&lt;ComplexVector Vec&gt; </td></tr>
<tr class="memitem:gab72e76c6970231b60f9946c52f762256"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gab72e76c6970231b60f9946c52f762256">aie::real</a> (const Vec &amp;v) -&gt; <a class="el" href="group__group__basic__types.html#classaie_1_1vector">vector</a>&lt; detail::utils::get_complex_component_type_t&lt; typename Vec::value_type &gt;, Vec::size()&gt;</td></tr>
<tr class="memdesc:gab72e76c6970231b60f9946c52f762256"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather and return the real components of a complex vector.  <br /></td></tr>
<tr class="separator:gab72e76c6970231b60f9946c52f762256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d8153ea6de2d58816ddd0275497f9b6" id="r_ga5d8153ea6de2d58816ddd0275497f9b6"><td class="memTemplParams" colspan="2">template&lt;ComplexElem Elem&gt; </td></tr>
<tr class="memitem:ga5d8153ea6de2d58816ddd0275497f9b6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga5d8153ea6de2d58816ddd0275497f9b6">aie::real</a> (Elem e) -&gt; detail::utils::get_complex_component_type_t&lt; <a class="el" href="namespaceaie.html#a69f163f105f63a640ffec2eea2230f93">operand_base_type_t</a>&lt; Elem &gt; &gt;</td></tr>
<tr class="memdesc:ga5d8153ea6de2d58816ddd0275497f9b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the real component of a complex value.  <br /></td></tr>
<tr class="separator:ga5d8153ea6de2d58816ddd0275497f9b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3f156cb322929539a61714b3c76d894" id="r_gae3f156cb322929539a61714b3c76d894"><td class="memTemplParams" colspan="2">template&lt;Vector Vec&gt; </td></tr>
<tr class="memitem:gae3f156cb322929539a61714b3c76d894"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gae3f156cb322929539a61714b3c76d894">aie::reverse</a> (const Vec &amp;v) -&gt; aie_dm_resource_remove_t&lt; Vec &gt;</td></tr>
<tr class="memdesc:gae3f156cb322929539a61714b3c76d894"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector whose contents are the same as the input vector, but in reverse order.  <br /></td></tr>
<tr class="separator:gae3f156cb322929539a61714b3c76d894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc3a9d872606af6257e1fe84772f5332" id="r_gabc3a9d872606af6257e1fe84772f5332"><td class="memTemplParams" colspan="2">template&lt;Elem E1, Elem E2, Mask M&gt; <br />
requires (<a class="el" href="namespaceaie.html#a33e8eaf5b5498a9e56eb727132ebe882">is_valid_elem_op_v</a>&lt;E1, E2&gt;)</td></tr>
<tr class="memitem:gabc3a9d872606af6257e1fe84772f5332"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group__basic__types.html#classaie_1_1vector">vector</a>&lt; <a class="el" href="namespaceaie.html#a69f163f105f63a640ffec2eea2230f93">operand_base_type_t</a>&lt; E1 &gt;, M::size()&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gabc3a9d872606af6257e1fe84772f5332">aie::select</a> (const E1 &amp;a, const E2 &amp;b, const M &amp;m)</td></tr>
<tr class="memdesc:gabc3a9d872606af6257e1fe84772f5332"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines the values of the input vector and value into a vector of the same size by using a mask that specifies which is the source input for each element of the output vector.  <br /></td></tr>
<tr class="separator:gabc3a9d872606af6257e1fe84772f5332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fa4a3e5fbcfff4b9658e7409dde5829" id="r_ga5fa4a3e5fbcfff4b9658e7409dde5829"><td class="memTemplParams" colspan="2">template&lt;Vector Vec, Elem E, Mask M&gt; <br />
requires (<a class="el" href="namespaceaie.html#a33e8eaf5b5498a9e56eb727132ebe882">is_valid_elem_op_v</a>&lt;E, typename Vec::value_type&gt; &amp;&amp; Vec::size() == M::size())</td></tr>
<tr class="memitem:ga5fa4a3e5fbcfff4b9658e7409dde5829"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga5fa4a3e5fbcfff4b9658e7409dde5829">aie::select</a> (const Vec &amp;v, E a, const M &amp;m) -&gt; aie_dm_resource_remove_t&lt; Vec &gt;</td></tr>
<tr class="memdesc:ga5fa4a3e5fbcfff4b9658e7409dde5829"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines the values of the input vector and value into a vector of the same size by using a mask that specifies which is the source input for each element of the output vector.  <br /></td></tr>
<tr class="separator:ga5fa4a3e5fbcfff4b9658e7409dde5829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccee4fb5f33efc7b29b6c1acb0477274" id="r_gaccee4fb5f33efc7b29b6c1acb0477274"><td class="memTemplParams" colspan="2">template&lt;Vector Vec1, Vector Vec2, Mask M&gt; <br />
requires (<a class="el" href="namespaceaie.html#a4aeecaeb33bbf13108f02dcec54b29cb">is_same_vector_v</a>&lt;Vec1, Vec2&gt; &amp;&amp; Vec1::size() == M::size())</td></tr>
<tr class="memitem:gaccee4fb5f33efc7b29b6c1acb0477274"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gaccee4fb5f33efc7b29b6c1acb0477274">aie::select</a> (const Vec1 &amp;v1, const Vec2 &amp;v2, const M &amp;m) -&gt; aie_dm_resource_remove_t&lt; Vec1 &gt;</td></tr>
<tr class="memdesc:gaccee4fb5f33efc7b29b6c1acb0477274"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines the values of the two input vectors into a vector of the same size by using a mask that specifies which is the source input for each element of the output vector.  <br /></td></tr>
<tr class="separator:gaccee4fb5f33efc7b29b6c1acb0477274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfe946dd1e1c3285dd6a7111cd2cfa35" id="r_gacfe946dd1e1c3285dd6a7111cd2cfa35"><td class="memTemplParams" colspan="2">template&lt;Elem E, Vector Vec, Mask M&gt; <br />
requires (<a class="el" href="namespaceaie.html#a33e8eaf5b5498a9e56eb727132ebe882">is_valid_elem_op_v</a>&lt;E, typename Vec::value_type&gt; &amp;&amp; Vec::size() == M::size())</td></tr>
<tr class="memitem:gacfe946dd1e1c3285dd6a7111cd2cfa35"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gacfe946dd1e1c3285dd6a7111cd2cfa35">aie::select</a> (E a, const Vec &amp;v, const M &amp;m) -&gt; aie_dm_resource_remove_t&lt; Vec &gt;</td></tr>
<tr class="memdesc:gacfe946dd1e1c3285dd6a7111cd2cfa35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines the values of the input value and vector into a vector of the same size by using a mask that specifies which is the source input for each element of the output vector.  <br /></td></tr>
<tr class="separator:gacfe946dd1e1c3285dd6a7111cd2cfa35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9800e13355efc0409c603d8418ef1d48" id="r_ga9800e13355efc0409c603d8418ef1d48"><td class="memTemplParams" colspan="2">template&lt;Vector Vec&gt; </td></tr>
<tr class="memitem:ga9800e13355efc0409c603d8418ef1d48"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga9800e13355efc0409c603d8418ef1d48">aie::shuffle_down</a> (const Vec &amp;v, unsigned n) -&gt; aie_dm_resource_remove_t&lt; Vec &gt;</td></tr>
<tr class="memdesc:ga9800e13355efc0409c603d8418ef1d48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector whose contents are the same as the input vector, but shifted down by n.  <br /></td></tr>
<tr class="separator:ga9800e13355efc0409c603d8418ef1d48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9726f01ffe377a76c0f96be0dca0fada" id="r_ga9726f01ffe377a76c0f96be0dca0fada"><td class="memTemplParams" colspan="2">template&lt;Vector Vec&gt; </td></tr>
<tr class="memitem:ga9726f01ffe377a76c0f96be0dca0fada"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga9726f01ffe377a76c0f96be0dca0fada">aie::shuffle_down_fill</a> (const Vec &amp;v, const Vec &amp;fill, unsigned n) -&gt; aie_dm_resource_remove_t&lt; Vec &gt;</td></tr>
<tr class="memdesc:ga9726f01ffe377a76c0f96be0dca0fada"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector whose contents are the same as the input vector, but shifted down by n.  <br /></td></tr>
<tr class="separator:ga9726f01ffe377a76c0f96be0dca0fada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga837af84180a54a03bdc5941c9b18fcc6" id="r_ga837af84180a54a03bdc5941c9b18fcc6"><td class="memTemplParams" colspan="2">template&lt;Vector Vec&gt; </td></tr>
<tr class="memitem:ga837af84180a54a03bdc5941c9b18fcc6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga837af84180a54a03bdc5941c9b18fcc6">aie::shuffle_down_replicate</a> (const Vec &amp;v, unsigned n) -&gt; aie_dm_resource_remove_t&lt; Vec &gt;</td></tr>
<tr class="memdesc:ga837af84180a54a03bdc5941c9b18fcc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector whose contents are the same as the input vector, but shifted down by n.  <br /></td></tr>
<tr class="separator:ga837af84180a54a03bdc5941c9b18fcc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2893f4d8c015299d249851854d8fbfb" id="r_gaa2893f4d8c015299d249851854d8fbfb"><td class="memTemplParams" colspan="2">template&lt;Vector Vec&gt; </td></tr>
<tr class="memitem:gaa2893f4d8c015299d249851854d8fbfb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gaa2893f4d8c015299d249851854d8fbfb">aie::shuffle_down_rotate</a> (const Vec &amp;v, unsigned n) -&gt; aie_dm_resource_remove_t&lt; Vec &gt;</td></tr>
<tr class="memdesc:gaa2893f4d8c015299d249851854d8fbfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector whose contents are the same as the input vector, but shifted down by n (elements wrap around):  <br /></td></tr>
<tr class="separator:gaa2893f4d8c015299d249851854d8fbfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92c3c5c59b8a9810af3e9b930ce06efb" id="r_ga92c3c5c59b8a9810af3e9b930ce06efb"><td class="memTemplParams" colspan="2">template&lt;Vector Vec&gt; </td></tr>
<tr class="memitem:ga92c3c5c59b8a9810af3e9b930ce06efb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga92c3c5c59b8a9810af3e9b930ce06efb">aie::shuffle_up</a> (const Vec &amp;v, unsigned n) -&gt; aie_dm_resource_remove_t&lt; Vec &gt;</td></tr>
<tr class="memdesc:ga92c3c5c59b8a9810af3e9b930ce06efb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector whose contents are the same as the input vector, but shifted up by n.  <br /></td></tr>
<tr class="separator:ga92c3c5c59b8a9810af3e9b930ce06efb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1b206f09c7571f4b0acd24de54340ea" id="r_gad1b206f09c7571f4b0acd24de54340ea"><td class="memTemplParams" colspan="2">template&lt;Vector Vec&gt; </td></tr>
<tr class="memitem:gad1b206f09c7571f4b0acd24de54340ea"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gad1b206f09c7571f4b0acd24de54340ea">aie::shuffle_up_fill</a> (const Vec &amp;v, const Vec &amp;fill, unsigned n) -&gt; aie_dm_resource_remove_t&lt; Vec &gt;</td></tr>
<tr class="memdesc:gad1b206f09c7571f4b0acd24de54340ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector whose contents are the same as the input vector, but shifted up by n.  <br /></td></tr>
<tr class="separator:gad1b206f09c7571f4b0acd24de54340ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5bf35c997fc4695b6add658bf17cd84" id="r_gae5bf35c997fc4695b6add658bf17cd84"><td class="memTemplParams" colspan="2">template&lt;Vector Vec&gt; </td></tr>
<tr class="memitem:gae5bf35c997fc4695b6add658bf17cd84"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gae5bf35c997fc4695b6add658bf17cd84">aie::shuffle_up_replicate</a> (const Vec &amp;v, unsigned n) -&gt; aie_dm_resource_remove_t&lt; Vec &gt;</td></tr>
<tr class="memdesc:gae5bf35c997fc4695b6add658bf17cd84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector whose contents are the same as the input vector, but shifted up by n.  <br /></td></tr>
<tr class="separator:gae5bf35c997fc4695b6add658bf17cd84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad014e5eb2f54fc73e379628f1af4adc7" id="r_gad014e5eb2f54fc73e379628f1af4adc7"><td class="memTemplParams" colspan="2">template&lt;Vector Vec&gt; </td></tr>
<tr class="memitem:gad014e5eb2f54fc73e379628f1af4adc7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gad014e5eb2f54fc73e379628f1af4adc7">aie::shuffle_up_rotate</a> (const Vec &amp;v, unsigned n) -&gt; aie_dm_resource_remove_t&lt; Vec &gt;</td></tr>
<tr class="memdesc:gad014e5eb2f54fc73e379628f1af4adc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector whose contents are the same as the input vector, but shifted up by n (elements wrap around):  <br /></td></tr>
<tr class="separator:gad014e5eb2f54fc73e379628f1af4adc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6833d69dd91b9cb0f03bd2576a73cc00" id="r_ga6833d69dd91b9cb0f03bd2576a73cc00"><td class="memTemplParams" colspan="2">template&lt;Vector Vec&gt; </td></tr>
<tr class="memitem:ga6833d69dd91b9cb0f03bd2576a73cc00"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga6833d69dd91b9cb0f03bd2576a73cc00">aie::transpose</a> (const Vec &amp;v, unsigned Row, unsigned Col) -&gt; aie_dm_resource_remove_t&lt; Vec &gt;</td></tr>
<tr class="memdesc:ga6833d69dd91b9cb0f03bd2576a73cc00"><td class="mdescLeft">&#160;</td><td class="mdescRight">The input vector is interpreted as a row-major matrix of the dimensions specified by Row and Col, the function returns a vector ordered as the transpose of the specified matrix.  <br /></td></tr>
<tr class="separator:ga6833d69dd91b9cb0f03bd2576a73cc00"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Class Documentation</h2>
<a name="classaie_1_1filter__mode" id="classaie_1_1filter__mode"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classaie_1_1filter__mode">&#9670;&#160;</a></span>aie::filter_mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class aie::filter_mode</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><div class="compoundTemplParams">template&lt;ElemBaseType T, unsigned Elems&gt;<br />
requires (<a class="el" href="group__group__utility__functions.html#a625fe645add467b5e19e60195bcc971a">arch::is</a>(<a class="el" href="group__group__utility__functions.html#ac2cdece807dd8a3785a30a968bf89892aa82d89a380c790b126450e584e106179">arch::Gen2</a>))<br />
class aie::filter_mode&lt; T, Elems &gt;</div><p>Enables precomputation of the filter element selection. </p>
<p>Allows to efficiently choose from multiple element selection alternatives at execution time, including odd/even, when performing a filter operation.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> condition = evaluated_at_runtime();</div>
<div class="line"><span class="keyword">auto</span> f = condition? <a class="code hl_function" href="#a574c4774377491c899d73388d15838c9">aie::filter_mode&lt;int8, 64&gt;::odd</a>(4)</div>
<div class="line">                  : <a class="code hl_namespace" href="namespaceaie.html">aie</a>::filter_mode&lt;<a class="code hl_typedef" href="types_8hpp.html#a3626f2f93183532b6e8b19234cc5c4d3">int8</a>, 64&gt;::<a class="code hl_function" href="#a19392680dd17be984521207f1e62d4be">even</a>(2);</div>
<div class="line"><a class="code hl_class" href="group__group__basic__types.html#classaie_1_1vector">aie::vector&lt;int8, 128&gt;</a> v = ...;</div>
<div class="line">aie::vector&lt;<a class="code hl_typedef" href="types_8hpp.html#a3626f2f93183532b6e8b19234cc5c4d3">int8</a>, 64&gt; w = <a class="code hl_function" href="#ga7dfeba667f965b1270cd23c3ecab919f">aie::filter</a>(v, f);</div>
<div class="ttc" id="agroup__group__basic__types_html_classaie_1_1vector"><div class="ttname"><a href="group__group__basic__types.html#classaie_1_1vector">aie::vector</a></div><div class="ttdoc">Type for vector registers.</div><div class="ttdef"><b>Definition</b> vector.hpp:73</div></div>
<div class="ttc" id="agroup__group__reshape_html_a19392680dd17be984521207f1e62d4be"><div class="ttname"><a href="#a19392680dd17be984521207f1e62d4be">aie::filter_mode::even</a></div><div class="ttdeci">static constexpr filter_mode even(unsigned chunk_size) noexcept</div><div class="ttdoc">Construts a filter_mode object that specifies the same pattern used in filter_even.</div><div class="ttdef"><b>Definition</b> aie.hpp:3181</div></div>
<div class="ttc" id="agroup__group__reshape_html_a574c4774377491c899d73388d15838c9"><div class="ttname"><a href="#a574c4774377491c899d73388d15838c9">aie::filter_mode::odd</a></div><div class="ttdeci">static constexpr filter_mode odd(unsigned chunk_size) noexcept</div><div class="ttdoc">Construts a filter_mode object that specifies the same pattern used in filter_odd.</div><div class="ttdef"><b>Definition</b> aie.hpp:3164</div></div>
<div class="ttc" id="agroup__group__reshape_html_ga7dfeba667f965b1270cd23c3ecab919f"><div class="ttname"><a href="#ga7dfeba667f965b1270cd23c3ecab919f">aie::filter</a></div><div class="ttdeci">auto filter(const Vec &amp;v, filter_mode&lt; T, Elems &gt; mode) -&gt; vector&lt; T, Elems/2 &gt;</div><div class="ttdoc">Returns a vector of half the size.</div><div class="ttdef"><b>Definition</b> aie.hpp:3208</div></div>
<div class="ttc" id="anamespaceaie_html"><div class="ttname"><a href="namespaceaie.html">aie</a></div><div class="ttdoc">Base namespace for AIE operations and types.</div><div class="ttdef"><b>Definition</b> accum.hpp:34</div></div>
<div class="ttc" id="atypes_8hpp_html_a3626f2f93183532b6e8b19234cc5c4d3"><div class="ttname"><a href="types_8hpp.html#a3626f2f93183532b6e8b19234cc5c4d3">int8</a></div><div class="ttdeci">int8_t int8</div><div class="ttdef"><b>Definition</b> types.hpp:20</div></div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type of the input vectors to be used in the interleave. </td></tr>
    <tr><td class="paramname">Elems</td><td>Number of elements of the input vectors to be used in the interleave.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#classaie_1_1interleave__unzip__mode" title="Enables precomputation of the interleave element selection.">interleave_unzip_mode</a> </dd>
<dd>
<a class="el" href="#classaie_1_1interleave__zip__mode" title="Enables precomputation of the interleave element selection.">interleave_zip_mode</a> </dd>
<dd>
<a class="el" href="#ga7dfeba667f965b1270cd23c3ecab919f" title="Returns a vector of half the size.">filter(const Vec &amp;v, filter_mode&lt;T, Elems&gt; mode)</a> </dd></dl>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Public Member Functions</h3></td></tr>
<tr class="memitem:a7c830cf0f56493f813981e1c43deaf95" id="r_a7c830cf0f56493f813981e1c43deaf95"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c830cf0f56493f813981e1c43deaf95">filter_mode</a> (const <a class="el" href="#classaie_1_1filter__mode">filter_mode</a> &amp;)=default</td></tr>
<tr class="memdesc:a7c830cf0f56493f813981e1c43deaf95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor for class <a class="el" href="#classaie_1_1filter__mode" title="Enables precomputation of the filter element selection.">filter_mode</a>.  <br /></td></tr>
<tr class="separator:a7c830cf0f56493f813981e1c43deaf95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Static Public Member Functions</h3></td></tr>
<tr class="memitem:a19392680dd17be984521207f1e62d4be" id="r_a19392680dd17be984521207f1e62d4be"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="#classaie_1_1filter__mode">filter_mode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a19392680dd17be984521207f1e62d4be">even</a> (unsigned chunk_size) noexcept</td></tr>
<tr class="memdesc:a19392680dd17be984521207f1e62d4be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construts a <a class="el" href="#classaie_1_1filter__mode" title="Enables precomputation of the filter element selection.">filter_mode</a> object that specifies the same pattern used in <a class="el" href="#gacaff9b63a0499a2549d93873f4d2516b">filter_even</a>.  <br /></td></tr>
<tr class="separator:a19392680dd17be984521207f1e62d4be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a574c4774377491c899d73388d15838c9" id="r_a574c4774377491c899d73388d15838c9"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="#classaie_1_1filter__mode">filter_mode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a574c4774377491c899d73388d15838c9">odd</a> (unsigned chunk_size) noexcept</td></tr>
<tr class="memdesc:a574c4774377491c899d73388d15838c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construts a <a class="el" href="#classaie_1_1filter__mode" title="Enables precomputation of the filter element selection.">filter_mode</a> object that specifies the same pattern used in <a class="el" href="#gae30977ff03f577797bd8afe4ec12ca0b">filter_odd</a>.  <br /></td></tr>
<tr class="separator:a574c4774377491c899d73388d15838c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Constructor &amp; Destructor Documentation</h4>
<a id="a7c830cf0f56493f813981e1c43deaf95" name="a7c830cf0f56493f813981e1c43deaf95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c830cf0f56493f813981e1c43deaf95">&#9670;&#160;</a></span>filter_mode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ElemBaseType T, unsigned Elems&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#classaie_1_1filter__mode">aie::filter_mode</a>&lt; T, Elems &gt;::filter_mode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#classaie_1_1filter__mode">filter_mode</a>&lt; T, Elems &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor for class <a class="el" href="#classaie_1_1filter__mode" title="Enables precomputation of the filter element selection.">filter_mode</a>. </p>

</div>
</div>
<h4 class="groupheader">Member Function Documentation</h4>
<a id="a19392680dd17be984521207f1e62d4be" name="a19392680dd17be984521207f1e62d4be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19392680dd17be984521207f1e62d4be">&#9670;&#160;</a></span>even()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ElemBaseType T, unsigned Elems&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="#classaie_1_1filter__mode">filter_mode</a> <a class="el" href="#classaie_1_1filter__mode">aie::filter_mode</a>&lt; T, Elems &gt;::even </td>
          <td>(</td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>chunk_size</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construts a <a class="el" href="#classaie_1_1filter__mode" title="Enables precomputation of the filter element selection.">filter_mode</a> object that specifies the same pattern used in <a class="el" href="#gacaff9b63a0499a2549d93873f4d2516b">filter_even</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chunk_size</td><td>Number of contiguous elements taken from the input vector. It must be a power of two.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gacaff9b63a0499a2549d93873f4d2516b" title="Returns a vector of half the size whose contents follow the following pattern.">filter_even</a> </dd></dl>

</div>
</div>
<a id="a574c4774377491c899d73388d15838c9" name="a574c4774377491c899d73388d15838c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a574c4774377491c899d73388d15838c9">&#9670;&#160;</a></span>odd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ElemBaseType T, unsigned Elems&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="#classaie_1_1filter__mode">filter_mode</a> <a class="el" href="#classaie_1_1filter__mode">aie::filter_mode</a>&lt; T, Elems &gt;::odd </td>
          <td>(</td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>chunk_size</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construts a <a class="el" href="#classaie_1_1filter__mode" title="Enables precomputation of the filter element selection.">filter_mode</a> object that specifies the same pattern used in <a class="el" href="#gae30977ff03f577797bd8afe4ec12ca0b">filter_odd</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chunk_size</td><td>Number of contiguous elements taken from the input vector. It must be a power of two.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gae30977ff03f577797bd8afe4ec12ca0b" title="Returns a vector of half the size whose contents follow the following pattern.">filter_odd</a> </dd></dl>

</div>
</div>

</div>
</div>
<a name="classaie_1_1interleave__unzip__mode" id="classaie_1_1interleave__unzip__mode"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classaie_1_1interleave__unzip__mode">&#9670;&#160;</a></span>aie::interleave_unzip_mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class aie::interleave_unzip_mode</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><div class="compoundTemplParams">template&lt;ElemBaseType T, unsigned Elems&gt;<br />
requires (<a class="el" href="group__group__utility__functions.html#a625fe645add467b5e19e60195bcc971a">arch::is</a>(<a class="el" href="group__group__utility__functions.html#ac2cdece807dd8a3785a30a968bf89892aa82d89a380c790b126450e584e106179">arch::Gen2</a>))<br />
class aie::interleave_unzip_mode&lt; T, Elems &gt;</div><p>Enables precomputation of the interleave element selection. </p>
<p>Allows to efficiently choose from multiple element selection alternatives at execution time, when performing an interleave_unzip operation.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> condition = evaluated_at_runtime();</div>
<div class="line"><span class="keyword">auto</span> m = condition? <a class="code hl_class" href="#classaie_1_1interleave__unzip__mode">aie::interleave_unzip_mode&lt;int8, 64&gt;</a>(4)</div>
<div class="line">                  : <a class="code hl_namespace" href="namespaceaie.html">aie</a>::<a class="code hl_function" href="#ad9acf9d726ecf0bc0c8acbd0c823dea4">interleave_unzip_mode</a>&lt;<a class="code hl_typedef" href="types_8hpp.html#a3626f2f93183532b6e8b19234cc5c4d3">int8</a>, 64&gt;(2);</div>
<div class="line"><a class="code hl_class" href="group__group__basic__types.html#classaie_1_1vector">aie::vector&lt;int8, 64&gt;</a> v = ..., w = ...;</div>
<div class="line">auto [even, odd] = <a class="code hl_function" href="#ga87ca1c50ee0039879af94f0d267f1c6b">aie::interleave_unzip</a>(v, w, m);</div>
<div class="ttc" id="agroup__group__reshape_html_ad9acf9d726ecf0bc0c8acbd0c823dea4"><div class="ttname"><a href="#ad9acf9d726ecf0bc0c8acbd0c823dea4">aie::interleave_unzip_mode::interleave_unzip_mode</a></div><div class="ttdeci">constexpr interleave_unzip_mode(unsigned chunk_size) noexcept</div><div class="ttdoc">Constructor for class interleave_unzip_mode.</div><div class="ttdef"><b>Definition</b> aie.hpp:2918</div></div>
<div class="ttc" id="agroup__group__reshape_html_classaie_1_1interleave__unzip__mode"><div class="ttname"><a href="#classaie_1_1interleave__unzip__mode">aie::interleave_unzip_mode</a></div><div class="ttdoc">Enables precomputation of the interleave element selection.</div><div class="ttdef"><b>Definition</b> aie.hpp:2908</div></div>
<div class="ttc" id="agroup__group__reshape_html_ga87ca1c50ee0039879af94f0d267f1c6b"><div class="ttname"><a href="#ga87ca1c50ee0039879af94f0d267f1c6b">aie::interleave_unzip</a></div><div class="ttdeci">auto interleave_unzip(const Vec1 &amp;v, const Vec2 &amp;w, unsigned chunk_size) -&gt; std::pair&lt; aie_dm_resource_remove_t&lt; Vec1 &gt;, aie_dm_resource_remove_t&lt; Vec1 &gt; &gt;</div><div class="ttdoc">Picks elements sequentially from the input vectors and writes them alternatively into the output vect...</div><div class="ttdef"><b>Definition</b> aie.hpp:3004</div></div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type of the input vectors to be used in the interleave. </td></tr>
    <tr><td class="paramname">Elems</td><td>Number of elements of the input vectors to be used in the interleave.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#classaie_1_1interleave__zip__mode" title="Enables precomputation of the interleave element selection.">interleave_zip_mode</a> </dd>
<dd>
<a class="el" href="#classaie_1_1filter__mode" title="Enables precomputation of the filter element selection.">filter_mode</a> </dd>
<dd>
<a class="el" href="#ga49b02d5125d3adaa055c644297343b8a" title="Picks elements sequentially from the input vectors and writes them alternatively into the output vect...">interleave_unzip(const Vec1&amp;, const Vec2&amp;, const interleave_unzip_mode&amp;)</a> </dd></dl>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Public Member Functions</h3></td></tr>
<tr class="memitem:af84337fd9b287e69948b65f3f4faaa57" id="r_af84337fd9b287e69948b65f3f4faaa57"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af84337fd9b287e69948b65f3f4faaa57">interleave_unzip_mode</a> (const <a class="el" href="#classaie_1_1interleave__unzip__mode">interleave_unzip_mode</a> &amp;)=default</td></tr>
<tr class="memdesc:af84337fd9b287e69948b65f3f4faaa57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor for class <a class="el" href="#classaie_1_1interleave__unzip__mode" title="Enables precomputation of the interleave element selection.">interleave_unzip_mode</a>.  <br /></td></tr>
<tr class="separator:af84337fd9b287e69948b65f3f4faaa57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9acf9d726ecf0bc0c8acbd0c823dea4" id="r_ad9acf9d726ecf0bc0c8acbd0c823dea4"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad9acf9d726ecf0bc0c8acbd0c823dea4">interleave_unzip_mode</a> (unsigned chunk_size) noexcept</td></tr>
<tr class="memdesc:ad9acf9d726ecf0bc0c8acbd0c823dea4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for class <a class="el" href="#classaie_1_1interleave__unzip__mode" title="Enables precomputation of the interleave element selection.">interleave_unzip_mode</a>.  <br /></td></tr>
<tr class="separator:ad9acf9d726ecf0bc0c8acbd0c823dea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Constructor &amp; Destructor Documentation</h4>
<a id="ad9acf9d726ecf0bc0c8acbd0c823dea4" name="ad9acf9d726ecf0bc0c8acbd0c823dea4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9acf9d726ecf0bc0c8acbd0c823dea4">&#9670;&#160;</a></span>interleave_unzip_mode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ElemBaseType T, unsigned Elems&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#classaie_1_1interleave__unzip__mode">aie::interleave_unzip_mode</a>&lt; T, Elems &gt;::interleave_unzip_mode </td>
          <td>(</td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>chunk_size</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel explicit">explicit</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for class <a class="el" href="#classaie_1_1interleave__unzip__mode" title="Enables precomputation of the interleave element selection.">interleave_unzip_mode</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chunk_size</td><td>Number of contiguous elements taken in an interleave_unzip operation. It must be a power of two. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af84337fd9b287e69948b65f3f4faaa57" name="af84337fd9b287e69948b65f3f4faaa57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af84337fd9b287e69948b65f3f4faaa57">&#9670;&#160;</a></span>interleave_unzip_mode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ElemBaseType T, unsigned Elems&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#classaie_1_1interleave__unzip__mode">aie::interleave_unzip_mode</a>&lt; T, Elems &gt;::interleave_unzip_mode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#classaie_1_1interleave__unzip__mode">interleave_unzip_mode</a>&lt; T, Elems &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor for class <a class="el" href="#classaie_1_1interleave__unzip__mode" title="Enables precomputation of the interleave element selection.">interleave_unzip_mode</a>. </p>

</div>
</div>

</div>
</div>
<a name="classaie_1_1interleave__zip__mode" id="classaie_1_1interleave__zip__mode"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classaie_1_1interleave__zip__mode">&#9670;&#160;</a></span>aie::interleave_zip_mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class aie::interleave_zip_mode</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><div class="compoundTemplParams">template&lt;ElemBaseType T, unsigned Elems&gt;<br />
requires (<a class="el" href="group__group__utility__functions.html#a625fe645add467b5e19e60195bcc971a">arch::is</a>(<a class="el" href="group__group__utility__functions.html#ac2cdece807dd8a3785a30a968bf89892aa82d89a380c790b126450e584e106179">arch::Gen2</a>))<br />
class aie::interleave_zip_mode&lt; T, Elems &gt;</div><p>Enables precomputation of the interleave element selection. </p>
<p>Allows to efficiently choose from multiple element selection alternatives at execution time, when performing an interleave_unzip operation.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> condition = evaluated_at_runtime();</div>
<div class="line"><span class="keyword">auto</span> m = condition? <a class="code hl_class" href="#classaie_1_1interleave__zip__mode">aie::interleave_zip_mode&lt;int8, 64&gt;</a>(4)</div>
<div class="line">                  : <a class="code hl_namespace" href="namespaceaie.html">aie</a>::<a class="code hl_function" href="#ac1541afe85990fe986dad2b2e6cd7f46">interleave_zip_mode</a>&lt;<a class="code hl_typedef" href="types_8hpp.html#a3626f2f93183532b6e8b19234cc5c4d3">int8</a>, 64&gt;(2);</div>
<div class="line"><a class="code hl_class" href="group__group__basic__types.html#classaie_1_1vector">aie::vector&lt;int8, 64&gt;</a> v = ..., w = ...;</div>
<div class="line">auto [low, high] = <a class="code hl_function" href="#ga88a182aac4704b1ad640383356008524">aie::interleave_zip</a>(v, w, m);</div>
<div class="ttc" id="agroup__group__reshape_html_ac1541afe85990fe986dad2b2e6cd7f46"><div class="ttname"><a href="#ac1541afe85990fe986dad2b2e6cd7f46">aie::interleave_zip_mode::interleave_zip_mode</a></div><div class="ttdeci">constexpr interleave_zip_mode(unsigned chunk_size) noexcept</div><div class="ttdoc">Constructor for class interleave_zip_mode.</div><div class="ttdef"><b>Definition</b> aie.hpp:2869</div></div>
<div class="ttc" id="agroup__group__reshape_html_classaie_1_1interleave__zip__mode"><div class="ttname"><a href="#classaie_1_1interleave__zip__mode">aie::interleave_zip_mode</a></div><div class="ttdoc">Enables precomputation of the interleave element selection.</div><div class="ttdef"><b>Definition</b> aie.hpp:2859</div></div>
<div class="ttc" id="agroup__group__reshape_html_ga88a182aac4704b1ad640383356008524"><div class="ttname"><a href="#ga88a182aac4704b1ad640383356008524">aie::interleave_zip</a></div><div class="ttdeci">auto interleave_zip(const Vec1 &amp;v, const Vec2 &amp;w, unsigned chunk_size) -&gt; std::pair&lt; aie_dm_resource_remove_t&lt; Vec1 &gt;, aie_dm_resource_remove_t&lt; Vec1 &gt; &gt;</div><div class="ttdoc">Picks elements alternatively from the input vectors and writes them sequentially into the output vect...</div><div class="ttdef"><b>Definition</b> aie.hpp:2946</div></div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type of the input vectors to be used in the interleave. </td></tr>
    <tr><td class="paramname">Elems</td><td>Number of elements of the input vectors to be used in the interleave.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#classaie_1_1interleave__unzip__mode" title="Enables precomputation of the interleave element selection.">interleave_unzip_mode</a> </dd>
<dd>
<a class="el" href="#ga39a16c9f4ab6c16d89fd3c16750cedfd" title="Picks elements alternatively from the input vectors and writes them sequentially into the output vect...">interleave_zip(const Vec1&amp;, const Vec2&amp;, const interleave_zip_mode&amp;)</a> </dd></dl>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Public Member Functions</h3></td></tr>
<tr class="memitem:a2194257b72830d654fbef9a8bb44896b" id="r_a2194257b72830d654fbef9a8bb44896b"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2194257b72830d654fbef9a8bb44896b">interleave_zip_mode</a> (const <a class="el" href="#classaie_1_1interleave__zip__mode">interleave_zip_mode</a> &amp;)=default</td></tr>
<tr class="memdesc:a2194257b72830d654fbef9a8bb44896b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor for class <a class="el" href="#classaie_1_1interleave__zip__mode" title="Enables precomputation of the interleave element selection.">interleave_zip_mode</a>.  <br /></td></tr>
<tr class="separator:a2194257b72830d654fbef9a8bb44896b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1541afe85990fe986dad2b2e6cd7f46" id="r_ac1541afe85990fe986dad2b2e6cd7f46"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac1541afe85990fe986dad2b2e6cd7f46">interleave_zip_mode</a> (unsigned chunk_size) noexcept</td></tr>
<tr class="memdesc:ac1541afe85990fe986dad2b2e6cd7f46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for class <a class="el" href="#classaie_1_1interleave__zip__mode" title="Enables precomputation of the interleave element selection.">interleave_zip_mode</a>.  <br /></td></tr>
<tr class="separator:ac1541afe85990fe986dad2b2e6cd7f46"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Constructor &amp; Destructor Documentation</h4>
<a id="ac1541afe85990fe986dad2b2e6cd7f46" name="ac1541afe85990fe986dad2b2e6cd7f46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1541afe85990fe986dad2b2e6cd7f46">&#9670;&#160;</a></span>interleave_zip_mode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ElemBaseType T, unsigned Elems&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#classaie_1_1interleave__zip__mode">aie::interleave_zip_mode</a>&lt; T, Elems &gt;::interleave_zip_mode </td>
          <td>(</td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>chunk_size</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel explicit">explicit</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for class <a class="el" href="#classaie_1_1interleave__zip__mode" title="Enables precomputation of the interleave element selection.">interleave_zip_mode</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chunk_size</td><td>Number of contiguous elements taken in an interleave_zip operation. It must be a power of two. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2194257b72830d654fbef9a8bb44896b" name="a2194257b72830d654fbef9a8bb44896b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2194257b72830d654fbef9a8bb44896b">&#9670;&#160;</a></span>interleave_zip_mode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ElemBaseType T, unsigned Elems&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#classaie_1_1interleave__zip__mode">aie::interleave_zip_mode</a>&lt; T, Elems &gt;::interleave_zip_mode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#classaie_1_1interleave__zip__mode">interleave_zip_mode</a>&lt; T, Elems &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor for class <a class="el" href="#classaie_1_1interleave__zip__mode" title="Enables precomputation of the interleave element selection.">interleave_zip_mode</a>. </p>

</div>
</div>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga7dfeba667f965b1270cd23c3ecab919f" name="ga7dfeba667f965b1270cd23c3ecab919f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7dfeba667f965b1270cd23c3ecab919f">&#9670;&#160;</a></span>filter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Vector Vec, ElemBaseType T, unsigned Elems&gt; <br />
requires (std::is_same_v&lt;typename Vec::value_type, T&gt; &amp;&amp; Vec::size() == Elems)</div>
      <table class="memname">
        <tr>
          <td class="memname">auto aie::filter </td>
          <td>(</td>
          <td class="paramtype">const Vec &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#classaie_1_1filter__mode">filter_mode</a>&lt; T, Elems &gt;</td>          <td class="paramname"><span class="paramname"><em>mode</em></span>&#160;) -&gt; <a class="el" href="group__group__basic__types.html#classaie_1_1vector">vector</a>&lt;T, Elems / 2&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector of half the size. </p>
<p>The output vector's contents may follow different patterns depending on how <a class="el" href="group__group__reshape.html">filter_mode</a> argument was constructed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Input vector. It must meet <a class="el" href="conceptaie_1_1Vector.html">aie::Vector</a>. </td></tr>
    <tr><td class="paramname">mode</td><td>Specifies what pattern will be used to pick the contents for the output vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#classaie_1_1filter__mode" title="Enables precomputation of the filter element selection.">filter_mode</a> </dd>
<dd>
<a class="el" href="#gacaff9b63a0499a2549d93873f4d2516b" title="Returns a vector of half the size whose contents follow the following pattern.">filter_even</a> </dd>
<dd>
<a class="el" href="#gae30977ff03f577797bd8afe4ec12ca0b" title="Returns a vector of half the size whose contents follow the following pattern.">filter_odd</a> </dd></dl>

</div>
</div>
<a id="gacaff9b63a0499a2549d93873f4d2516b" name="gacaff9b63a0499a2549d93873f4d2516b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacaff9b63a0499a2549d93873f4d2516b">&#9670;&#160;</a></span>filter_even()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Vector Vec&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto aie::filter_even </td>
          <td>(</td>
          <td class="paramtype">const Vec &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>chunk_size</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;) -&gt; <a class="el" href="group__group__basic__types.html#classaie_1_1vector">vector</a>&lt;typename Vec::value_type, Vec::size() / 2&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector of half the size whose contents follow the following pattern. </p>
<div class="fragment"><div class="line">out = { v[0:chunk_size), v[2*chunk_size:3*chunk_size), ... }</div>
</div><!-- fragment --><p>For example</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="#gacaff9b63a0499a2549d93873f4d2516b">aie::filter_even</a>(v, 1) = { v[0], v[2], ... }</div>
<div class="line"><a class="code hl_function" href="#gacaff9b63a0499a2549d93873f4d2516b">aie::filter_even</a>(v, 2) = { v[0], v[1], v[4], v[5], ... }</div>
<div class="ttc" id="agroup__group__reshape_html_gacaff9b63a0499a2549d93873f4d2516b"><div class="ttname"><a href="#gacaff9b63a0499a2549d93873f4d2516b">aie::filter_even</a></div><div class="ttdeci">auto filter_even(const Vec &amp;v, unsigned chunk_size=1) -&gt; vector&lt; typename Vec::value_type, Vec::size()/2 &gt;</div><div class="ttdoc">Returns a vector of half the size whose contents follow the following pattern.</div><div class="ttdef"><b>Definition</b> aie.hpp:3274</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Input vector. Must meet <a class="el" href="conceptaie_1_1Vector.html">aie::Vector</a>. </td></tr>
    <tr><td class="paramname">chunk_size</td><td>Number of contiguous elements taken from the input vector. Must be a power of two.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#classaie_1_1filter__mode" title="Enables precomputation of the filter element selection.">filter_mode</a> </dd>
<dd>
<a class="el" href="#ga7dfeba667f965b1270cd23c3ecab919f" title="Returns a vector of half the size.">filter(const Vec &amp;v, filter_mode&lt;T, Elems&gt; mode)</a> </dd></dl>

</div>
</div>
<a id="gae30977ff03f577797bd8afe4ec12ca0b" name="gae30977ff03f577797bd8afe4ec12ca0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae30977ff03f577797bd8afe4ec12ca0b">&#9670;&#160;</a></span>filter_odd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Vector Vec&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto aie::filter_odd </td>
          <td>(</td>
          <td class="paramtype">const Vec &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>chunk_size</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;) -&gt; <a class="el" href="group__group__basic__types.html#classaie_1_1vector">vector</a>&lt;typename Vec::value_type, Vec::size() / 2&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector of half the size whose contents follow the following pattern. </p>
<div class="fragment"><div class="line">out = { v[chunk_size:2*chunk_size), v[3*chunk_size:4*chunk_size), ... }</div>
</div><!-- fragment --><p>For example</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="#gae30977ff03f577797bd8afe4ec12ca0b">aie::filter_odd</a>(v, 1) = { v[1], v[3], ... }</div>
<div class="line"><a class="code hl_function" href="#gae30977ff03f577797bd8afe4ec12ca0b">aie::filter_odd</a>(v, 2) = { v[2], v[3], v[6], v[7], ... }</div>
<div class="ttc" id="agroup__group__reshape_html_gae30977ff03f577797bd8afe4ec12ca0b"><div class="ttname"><a href="#gae30977ff03f577797bd8afe4ec12ca0b">aie::filter_odd</a></div><div class="ttdeci">auto filter_odd(const Vec &amp;v, unsigned chunk_size=1) -&gt; vector&lt; typename Vec::value_type, Vec::size()/2 &gt;</div><div class="ttdoc">Returns a vector of half the size whose contents follow the following pattern.</div><div class="ttdef"><b>Definition</b> aie.hpp:3237</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Input vector. Must meet <a class="el" href="conceptaie_1_1Vector.html">aie::Vector</a>. </td></tr>
    <tr><td class="paramname">chunk_size</td><td>Number of contiguous elements taken from the input vector. Must be a power of two.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#classaie_1_1filter__mode" title="Enables precomputation of the filter element selection.">filter_mode</a> </dd>
<dd>
<a class="el" href="#ga7dfeba667f965b1270cd23c3ecab919f" title="Returns a vector of half the size.">filter(const Vec &amp;v, filter_mode&lt;T, Elems&gt; mode)</a> </dd></dl>

</div>
</div>
<a id="ga6ef610fa6d4fe1fd67f93d1a7a024266" name="ga6ef610fa6d4fe1fd67f93d1a7a024266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ef610fa6d4fe1fd67f93d1a7a024266">&#9670;&#160;</a></span>imag() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ComplexVector Vec&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto aie::imag </td>
          <td>(</td>
          <td class="paramtype">const Vec &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="group__group__basic__types.html#classaie_1_1vector">vector</a>&lt;detail::utils::get_complex_component_type_t&lt;typename Vec::value_type&gt;, Vec::size()&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gather and return the imaginary components of a complex vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Complex input vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga61bca811fa4b427c9a8e490763e9d334" name="ga61bca811fa4b427c9a8e490763e9d334"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61bca811fa4b427c9a8e490763e9d334">&#9670;&#160;</a></span>imag() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ComplexElem Elem&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto aie::imag </td>
          <td>(</td>
          <td class="paramtype">Elem</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td> -&gt; detail::utils::get_complex_component_type_t&lt;<a class="el" href="namespaceaie.html#a69f163f105f63a640ffec2eea2230f93">operand_base_type_t</a>&lt;Elem&gt;&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the imaginary component of a complex value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>Complex input </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga87ca1c50ee0039879af94f0d267f1c6b" name="ga87ca1c50ee0039879af94f0d267f1c6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87ca1c50ee0039879af94f0d267f1c6b">&#9670;&#160;</a></span>interleave_unzip() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Vector Vec1, Vector Vec2&gt; <br />
requires (<a class="el" href="namespaceaie.html#a4aeecaeb33bbf13108f02dcec54b29cb">is_same_vector_v</a>&lt;Vec1, Vec2&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname">auto aie::interleave_unzip </td>
          <td>(</td>
          <td class="paramtype">const Vec1 &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vec2 &amp;</td>          <td class="paramname"><span class="paramname"><em>w</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>chunk_size</em></span>&#160;) -&gt; std::pair&lt;aie_dm_resource_remove_t&lt;Vec1&gt;, aie_dm_resource_remove_t&lt;Vec1&gt;&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Picks elements sequentially from the input vectors and writes them alternatively into the output vectors. </p>
<div class="fragment"><div class="line">out = { v[0:chunk_size], v[2*chunk_size:3*chunk_size], ..., w[0:chunk_size], w[2*chunk_size:3*chunk_size], ..., v[chunk_size:2*chunk_size], v[3*chunk_size:4*chunk_size], ..., w[chunk_size:2*chunk_size], w[3*chunk_size:4*chunk_size], ... }</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>First input vector. Must meet <a class="el" href="conceptaie_1_1Vector.html">aie::Vector</a>. </td></tr>
    <tr><td class="paramname">w</td><td>Second input vector. Must meet <a class="el" href="conceptaie_1_1Vector.html">aie::Vector</a>. </td></tr>
    <tr><td class="paramname">chunk_size</td><td>Number of contiguous elements taken from each input vector. It must be a power of two. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga49b02d5125d3adaa055c644297343b8a" name="ga49b02d5125d3adaa055c644297343b8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49b02d5125d3adaa055c644297343b8a">&#9670;&#160;</a></span>interleave_unzip() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Vector Vec1, Vector Vec2, ElemBaseType T, unsigned Elems&gt; <br />
requires (<a class="el" href="group__group__utility__functions.html#a625fe645add467b5e19e60195bcc971a">arch::is</a>(<a class="el" href="group__group__utility__functions.html#ac2cdece807dd8a3785a30a968bf89892aa82d89a380c790b126450e584e106179">arch::Gen2</a>) &amp;&amp; <a class="el" href="namespaceaie.html#a4aeecaeb33bbf13108f02dcec54b29cb">is_same_vector_v</a>&lt;Vec1, Vec2&gt; &amp;&amp; std::is_same_v&lt;typename Vec1::value_type, T&gt; &amp;&amp; Vec1::size() == Elems)</div>
      <table class="memname">
        <tr>
          <td class="memname">auto aie::interleave_unzip </td>
          <td>(</td>
          <td class="paramtype">const Vec1 &amp;</td>          <td class="paramname"><span class="paramname"><em>v1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vec2 &amp;</td>          <td class="paramname"><span class="paramname"><em>v2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#classaie_1_1interleave__unzip__mode">interleave_unzip_mode</a>&lt; T, Elems &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>mode</em></span>&#160;) -&gt; std::pair&lt;aie_dm_resource_remove_t&lt;Vec1&gt;, aie_dm_resource_remove_t&lt;Vec1&gt;&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Picks elements sequentially from the input vectors and writes them alternatively into the output vectors. </p>
<p>In cases where the interleave chunk size is picked at execution time, this overload allows the user to precompute the interleave mode in advance (it is an expensive operation).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>First input vector. Must meet <a class="el" href="conceptaie_1_1Vector.html">aie::Vector</a>. </td></tr>
    <tr><td class="paramname">v2</td><td>Second input vector. Must meet <a class="el" href="conceptaie_1_1Vector.html">aie::Vector</a>. </td></tr>
    <tr><td class="paramname">mode</td><td>Precomputed interleave mode, specifying the number of contiguous elements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#classaie_1_1interleave__unzip__mode" title="Enables precomputation of the interleave element selection.">interleave_unzip_mode</a> </dd>
<dd>
<a class="el" href="#ga87ca1c50ee0039879af94f0d267f1c6b" title="Picks elements sequentially from the input vectors and writes them alternatively into the output vect...">interleave_unzip(const Vec1&amp;, const Vec2&amp;, unsigned)</a> </dd></dl>

</div>
</div>
<a id="ga39a16c9f4ab6c16d89fd3c16750cedfd" name="ga39a16c9f4ab6c16d89fd3c16750cedfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39a16c9f4ab6c16d89fd3c16750cedfd">&#9670;&#160;</a></span>interleave_zip() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Vector Vec1, Vector Vec2, ElemBaseType T, unsigned Elems&gt; <br />
requires (<a class="el" href="group__group__utility__functions.html#a625fe645add467b5e19e60195bcc971a">arch::is</a>(<a class="el" href="group__group__utility__functions.html#ac2cdece807dd8a3785a30a968bf89892aa82d89a380c790b126450e584e106179">arch::Gen2</a>) &amp;&amp; <a class="el" href="namespaceaie.html#a4aeecaeb33bbf13108f02dcec54b29cb">is_same_vector_v</a>&lt;Vec1, Vec2&gt; &amp;&amp; std::is_same_v&lt;typename Vec1::value_type, T&gt; &amp;&amp; Vec1::size() == Elems)</div>
      <table class="memname">
        <tr>
          <td class="memname">auto aie::interleave_zip </td>
          <td>(</td>
          <td class="paramtype">const Vec1 &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vec2 &amp;</td>          <td class="paramname"><span class="paramname"><em>w</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#classaie_1_1interleave__zip__mode">interleave_zip_mode</a>&lt; T, Elems &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>mode</em></span>&#160;) -&gt; std::pair&lt;aie_dm_resource_remove_t&lt;Vec1&gt;, aie_dm_resource_remove_t&lt;Vec1&gt;&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Picks elements alternatively from the input vectors and writes them sequentially into the output vectors. </p>
<p>In cases where the interleave chunk size is picked at execution time, this overload allows the user to precompute the interleave mode in advance (it is an expensive operation).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>First input vector. Must meet <a class="el" href="conceptaie_1_1Vector.html">aie::Vector</a>. </td></tr>
    <tr><td class="paramname">w</td><td>Second input vector. Must meet <a class="el" href="conceptaie_1_1Vector.html">aie::Vector</a>. </td></tr>
    <tr><td class="paramname">mode</td><td>Precomputed interleave mode, specifying the number of contiguous elements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#classaie_1_1interleave__zip__mode" title="Enables precomputation of the interleave element selection.">interleave_zip_mode</a> </dd>
<dd>
<a class="el" href="#ga88a182aac4704b1ad640383356008524" title="Picks elements alternatively from the input vectors and writes them sequentially into the output vect...">interleave_zip(const Vec1&amp;, const Vec2&amp;, unsigned)</a> </dd></dl>

</div>
</div>
<a id="ga88a182aac4704b1ad640383356008524" name="ga88a182aac4704b1ad640383356008524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88a182aac4704b1ad640383356008524">&#9670;&#160;</a></span>interleave_zip() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Vector Vec1, Vector Vec2&gt; <br />
requires (<a class="el" href="namespaceaie.html#a4aeecaeb33bbf13108f02dcec54b29cb">is_same_vector_v</a>&lt;Vec1, Vec2&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname">auto aie::interleave_zip </td>
          <td>(</td>
          <td class="paramtype">const Vec1 &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vec2 &amp;</td>          <td class="paramname"><span class="paramname"><em>w</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>chunk_size</em></span>&#160;) -&gt; std::pair&lt;aie_dm_resource_remove_t&lt;Vec1&gt;, aie_dm_resource_remove_t&lt;Vec1&gt;&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Picks elements alternatively from the input vectors and writes them sequentially into the output vectors. </p>
<div class="fragment"><div class="line">out = { v[0:chunk_size], w[0:chunk_size], v[chunk_size:2*chunk_size], w[chunk_size:2*chunk_size], ... }</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>First input vector. Must meet <a class="el" href="conceptaie_1_1Vector.html">aie::Vector</a>. </td></tr>
    <tr><td class="paramname">w</td><td>Second input vector. Must meet <a class="el" href="conceptaie_1_1Vector.html">aie::Vector</a>. </td></tr>
    <tr><td class="paramname">chunk_size</td><td>Number of contiguous elements taken from each input vector. It must be a power of two. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab72e76c6970231b60f9946c52f762256" name="gab72e76c6970231b60f9946c52f762256"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab72e76c6970231b60f9946c52f762256">&#9670;&#160;</a></span>real() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ComplexVector Vec&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto aie::real </td>
          <td>(</td>
          <td class="paramtype">const Vec &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="group__group__basic__types.html#classaie_1_1vector">vector</a>&lt;detail::utils::get_complex_component_type_t&lt;typename Vec::value_type&gt;, Vec::size()&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gather and return the real components of a complex vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Complex input vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5d8153ea6de2d58816ddd0275497f9b6" name="ga5d8153ea6de2d58816ddd0275497f9b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d8153ea6de2d58816ddd0275497f9b6">&#9670;&#160;</a></span>real() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ComplexElem Elem&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto aie::real </td>
          <td>(</td>
          <td class="paramtype">Elem</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td> -&gt; detail::utils::get_complex_component_type_t&lt;<a class="el" href="namespaceaie.html#a69f163f105f63a640ffec2eea2230f93">operand_base_type_t</a>&lt;Elem&gt;&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the real component of a complex value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>Complex input </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae3f156cb322929539a61714b3c76d894" name="gae3f156cb322929539a61714b3c76d894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3f156cb322929539a61714b3c76d894">&#9670;&#160;</a></span>reverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Vector Vec&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto aie::reverse </td>
          <td>(</td>
          <td class="paramtype">const Vec &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td> -&gt; aie_dm_resource_remove_t&lt;Vec&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector whose contents are the same as the input vector, but in reverse order. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; Elems; ++i)</div>
<div class="line">    out[i] = in[Elems - i - 1];</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Input vector. The type must meet <a class="el" href="conceptaie_1_1Vector.html">aie::Vector</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabc3a9d872606af6257e1fe84772f5332" name="gabc3a9d872606af6257e1fe84772f5332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc3a9d872606af6257e1fe84772f5332">&#9670;&#160;</a></span>select() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Elem E1, Elem E2, Mask M&gt; <br />
requires (<a class="el" href="namespaceaie.html#a33e8eaf5b5498a9e56eb727132ebe882">is_valid_elem_op_v</a>&lt;E1, E2&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__basic__types.html#classaie_1_1vector">vector</a>&lt; <a class="el" href="namespaceaie.html#a69f163f105f63a640ffec2eea2230f93">operand_base_type_t</a>&lt; E1 &gt;, M::size()&gt; aie::select </td>
          <td>(</td>
          <td class="paramtype">const E1 &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const E2 &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const M &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Combines the values of the input vector and value into a vector of the same size by using a mask that specifies which is the source input for each element of the output vector. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; Elems; ++i)</div>
<div class="line">    out[i] = m[i] == 0? a : b;</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Input value. The type must meet <a class="el" href="conceptaie_1_1Elem.html">aie::Elem</a>. </td></tr>
    <tr><td class="paramname">b</td><td>Input value. The type must meet <a class="el" href="conceptaie_1_1Elem.html">aie::Elem</a>. </td></tr>
    <tr><td class="paramname">m</td><td><a class="el" href="conceptaie_1_1Mask.html">Mask</a> that specifies the source input for each output element. The type must meet <a class="el" href="conceptaie_1_1Mask.html">aie::Mask</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5fa4a3e5fbcfff4b9658e7409dde5829" name="ga5fa4a3e5fbcfff4b9658e7409dde5829"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5fa4a3e5fbcfff4b9658e7409dde5829">&#9670;&#160;</a></span>select() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Vector Vec, Elem E, Mask M&gt; <br />
requires (<a class="el" href="namespaceaie.html#a33e8eaf5b5498a9e56eb727132ebe882">is_valid_elem_op_v</a>&lt;E, typename Vec::value_type&gt; &amp;&amp; Vec::size() == M::size())</div>
      <table class="memname">
        <tr>
          <td class="memname">auto aie::select </td>
          <td>(</td>
          <td class="paramtype">const Vec &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">E</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const M &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;) -&gt; aie_dm_resource_remove_t&lt;Vec&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Combines the values of the input vector and value into a vector of the same size by using a mask that specifies which is the source input for each element of the output vector. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; Elems; ++i)</div>
<div class="line">    out[i] = m[i] == 0? v[i] : a;</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Input vector. The type must meet <a class="el" href="conceptaie_1_1Vector.html">aie::Vector</a>. </td></tr>
    <tr><td class="paramname">a</td><td>Input value. The type must meet <a class="el" href="conceptaie_1_1Elem.html">aie::Elem</a>. </td></tr>
    <tr><td class="paramname">m</td><td><a class="el" href="conceptaie_1_1Mask.html">Mask</a> that specifies the source input for each output element. The type must meet <a class="el" href="conceptaie_1_1Mask.html">aie::Mask</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaccee4fb5f33efc7b29b6c1acb0477274" name="gaccee4fb5f33efc7b29b6c1acb0477274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaccee4fb5f33efc7b29b6c1acb0477274">&#9670;&#160;</a></span>select() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Vector Vec1, Vector Vec2, Mask M&gt; <br />
requires (<a class="el" href="namespaceaie.html#a4aeecaeb33bbf13108f02dcec54b29cb">is_same_vector_v</a>&lt;Vec1, Vec2&gt; &amp;&amp; Vec1::size() == M::size())</div>
      <table class="memname">
        <tr>
          <td class="memname">auto aie::select </td>
          <td>(</td>
          <td class="paramtype">const Vec1 &amp;</td>          <td class="paramname"><span class="paramname"><em>v1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vec2 &amp;</td>          <td class="paramname"><span class="paramname"><em>v2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const M &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;) -&gt; aie_dm_resource_remove_t&lt;Vec1&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Combines the values of the two input vectors into a vector of the same size by using a mask that specifies which is the source input for each element of the output vector. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; Elems; ++i)</div>
<div class="line">    out[i] = m[i] == 0? v1[i] : v2[i];</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>First input vector. The type must meet <a class="el" href="conceptaie_1_1Vector.html">aie::Vector</a>. </td></tr>
    <tr><td class="paramname">v2</td><td>Second input vector. The type must meet <a class="el" href="conceptaie_1_1Vector.html">aie::Vector</a>. </td></tr>
    <tr><td class="paramname">m</td><td><a class="el" href="conceptaie_1_1Mask.html">Mask</a> that specifies the source input for each output element. The type must meet <a class="el" href="conceptaie_1_1Mask.html">aie::Mask</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacfe946dd1e1c3285dd6a7111cd2cfa35" name="gacfe946dd1e1c3285dd6a7111cd2cfa35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacfe946dd1e1c3285dd6a7111cd2cfa35">&#9670;&#160;</a></span>select() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Elem E, Vector Vec, Mask M&gt; <br />
requires (<a class="el" href="namespaceaie.html#a33e8eaf5b5498a9e56eb727132ebe882">is_valid_elem_op_v</a>&lt;E, typename Vec::value_type&gt; &amp;&amp; Vec::size() == M::size())</div>
      <table class="memname">
        <tr>
          <td class="memname">auto aie::select </td>
          <td>(</td>
          <td class="paramtype">E</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vec &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const M &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;) -&gt; aie_dm_resource_remove_t&lt;Vec&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Combines the values of the input value and vector into a vector of the same size by using a mask that specifies which is the source input for each element of the output vector. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; Elems; ++i)</div>
<div class="line">    out[i] = m[i] == 0? a : v[i];</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Input value. The type must meet <a class="el" href="conceptaie_1_1Elem.html">aie::Elem</a>. </td></tr>
    <tr><td class="paramname">v</td><td>Input vector. The type must meet <a class="el" href="conceptaie_1_1Vector.html">aie::Vector</a>. </td></tr>
    <tr><td class="paramname">m</td><td><a class="el" href="conceptaie_1_1Mask.html">Mask</a> that specifies the source input for each output element. The type must meet <a class="el" href="conceptaie_1_1Mask.html">aie::Mask</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9800e13355efc0409c603d8418ef1d48" name="ga9800e13355efc0409c603d8418ef1d48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9800e13355efc0409c603d8418ef1d48">&#9670;&#160;</a></span>shuffle_down()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Vector Vec&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto aie::shuffle_down </td>
          <td>(</td>
          <td class="paramtype">const Vec &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;) -&gt; aie_dm_resource_remove_t&lt;Vec&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector whose contents are the same as the input vector, but shifted down by n. </p>
<p>Elements do not wrap around and new elements are undefined.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; Elems - n; ++i)</div>
<div class="line">    out[i] = in[i + n]</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Input vector. The type must meet <a class="el" href="conceptaie_1_1Vector.html">aie::Vector</a>. </td></tr>
    <tr><td class="paramname">n</td><td>Distance for the elements to be shifted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9726f01ffe377a76c0f96be0dca0fada" name="ga9726f01ffe377a76c0f96be0dca0fada"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9726f01ffe377a76c0f96be0dca0fada">&#9670;&#160;</a></span>shuffle_down_fill()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Vector Vec&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto aie::shuffle_down_fill </td>
          <td>(</td>
          <td class="paramtype">const Vec &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vec &amp;</td>          <td class="paramname"><span class="paramname"><em>fill</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;) -&gt; aie_dm_resource_remove_t&lt;Vec&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector whose contents are the same as the input vector, but shifted down by n. </p>
<p>Elements do not wrap around and new elements are filled from a second vector.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; Elems - n; ++i)</div>
<div class="line">    out[i] = in[i + n]</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; n; ++i)</div>
<div class="line">    out[i + Elems - n] = fill[i]</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Input vector. The type must meet <a class="el" href="conceptaie_1_1Vector.html">aie::Vector</a>. </td></tr>
    <tr><td class="paramname">fill</td><td>Second input vector used to fill the elements in the upper part of the output vector. </td></tr>
    <tr><td class="paramname">n</td><td>Distance for the elements to be shifted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga837af84180a54a03bdc5941c9b18fcc6" name="ga837af84180a54a03bdc5941c9b18fcc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga837af84180a54a03bdc5941c9b18fcc6">&#9670;&#160;</a></span>shuffle_down_replicate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Vector Vec&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto aie::shuffle_down_replicate </td>
          <td>(</td>
          <td class="paramtype">const Vec &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;) -&gt; aie_dm_resource_remove_t&lt;Vec&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector whose contents are the same as the input vector, but shifted down by n. </p>
<p>Elements do not wrap around and new elements are copies of the last element of the input vector.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; Elems - n; ++i)</div>
<div class="line">    out[i] = in[i + n]</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = Elems - n; i &lt; Elems; ++i)</div>
<div class="line">    out[i] = in[Elems - 1];</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Input vector. The type must meet <a class="el" href="conceptaie_1_1Vector.html">aie::Vector</a>. </td></tr>
    <tr><td class="paramname">n</td><td>Distance for the elements to be shifted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa2893f4d8c015299d249851854d8fbfb" name="gaa2893f4d8c015299d249851854d8fbfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa2893f4d8c015299d249851854d8fbfb">&#9670;&#160;</a></span>shuffle_down_rotate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Vector Vec&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto aie::shuffle_down_rotate </td>
          <td>(</td>
          <td class="paramtype">const Vec &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;) -&gt; aie_dm_resource_remove_t&lt;Vec&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector whose contents are the same as the input vector, but shifted down by n (elements wrap around): </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; Elems; ++i)</div>
<div class="line">    out[i] = in[(i + n) % Elems]</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Input vector. The type must meet <a class="el" href="conceptaie_1_1Vector.html">aie::Vector</a>. </td></tr>
    <tr><td class="paramname">n</td><td>Distance for the elements to be shifted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga92c3c5c59b8a9810af3e9b930ce06efb" name="ga92c3c5c59b8a9810af3e9b930ce06efb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92c3c5c59b8a9810af3e9b930ce06efb">&#9670;&#160;</a></span>shuffle_up()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Vector Vec&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto aie::shuffle_up </td>
          <td>(</td>
          <td class="paramtype">const Vec &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;) -&gt; aie_dm_resource_remove_t&lt;Vec&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector whose contents are the same as the input vector, but shifted up by n. </p>
<p>Elements do not wrap around and new elements are undefined.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; Elems - n; ++i)</div>
<div class="line">    out[i + n] = in[i]</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Input vector. The type must meet <a class="el" href="conceptaie_1_1Vector.html">aie::Vector</a>. </td></tr>
    <tr><td class="paramname">n</td><td>Distance for the elements to be shifted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad1b206f09c7571f4b0acd24de54340ea" name="gad1b206f09c7571f4b0acd24de54340ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1b206f09c7571f4b0acd24de54340ea">&#9670;&#160;</a></span>shuffle_up_fill()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Vector Vec&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto aie::shuffle_up_fill </td>
          <td>(</td>
          <td class="paramtype">const Vec &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vec &amp;</td>          <td class="paramname"><span class="paramname"><em>fill</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;) -&gt; aie_dm_resource_remove_t&lt;Vec&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector whose contents are the same as the input vector, but shifted up by n. </p>
<p>Elements do not wrap around and new elements are filled from a second vector.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; Elems - n; ++i)</div>
<div class="line">    out[i + n] = in[i]</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; n; ++i)</div>
<div class="line">    out[i] = fill[i + Elems - n];</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Input vector. The type must meet <a class="el" href="conceptaie_1_1Vector.html">aie::Vector</a>. </td></tr>
    <tr><td class="paramname">fill</td><td>Second input vector used to fill the elements in the lower part of the output vector. </td></tr>
    <tr><td class="paramname">n</td><td>Distance for the elements to be shifted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae5bf35c997fc4695b6add658bf17cd84" name="gae5bf35c997fc4695b6add658bf17cd84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5bf35c997fc4695b6add658bf17cd84">&#9670;&#160;</a></span>shuffle_up_replicate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Vector Vec&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto aie::shuffle_up_replicate </td>
          <td>(</td>
          <td class="paramtype">const Vec &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;) -&gt; aie_dm_resource_remove_t&lt;Vec&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector whose contents are the same as the input vector, but shifted up by n. </p>
<p>Elements do not wrap around and new elements are copies of the first element of the input vector.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; Elems - n; ++i)</div>
<div class="line">    out[i + n] = in[i]</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; n; ++i)</div>
<div class="line">    out[i] = in[0];</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Input vector. The type must meet <a class="el" href="conceptaie_1_1Vector.html">aie::Vector</a>. </td></tr>
    <tr><td class="paramname">n</td><td>Distance for the elements to be shifted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad014e5eb2f54fc73e379628f1af4adc7" name="gad014e5eb2f54fc73e379628f1af4adc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad014e5eb2f54fc73e379628f1af4adc7">&#9670;&#160;</a></span>shuffle_up_rotate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Vector Vec&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto aie::shuffle_up_rotate </td>
          <td>(</td>
          <td class="paramtype">const Vec &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;) -&gt; aie_dm_resource_remove_t&lt;Vec&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector whose contents are the same as the input vector, but shifted up by n (elements wrap around): </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; Elems; ++i)</div>
<div class="line">    out[i] = in[(i - n) % Elems]</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Input vector. The type must meet <a class="el" href="conceptaie_1_1Vector.html">aie::Vector</a>. </td></tr>
    <tr><td class="paramname">n</td><td>Distance for the elements to be shifted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6833d69dd91b9cb0f03bd2576a73cc00" name="ga6833d69dd91b9cb0f03bd2576a73cc00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6833d69dd91b9cb0f03bd2576a73cc00">&#9670;&#160;</a></span>transpose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Vector Vec&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto aie::transpose </td>
          <td>(</td>
          <td class="paramtype">const Vec &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>Row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>Col</em></span>&#160;) -&gt; aie_dm_resource_remove_t&lt;Vec&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The input vector is interpreted as a row-major matrix of the dimensions specified by Row and Col, the function returns a vector ordered as the transpose of the specified matrix. </p>
<p>For Row equal to 1, the input vector is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Input vector. The type must meet <a class="el" href="conceptaie_1_1Vector.html">aie::Vector</a>, with number of elements equal to Row * Col. </td></tr>
    <tr><td class="paramname">Row</td><td>Number of rows of the input matrix shape. </td></tr>
    <tr><td class="paramname">Col</td><td>Number of cols of the input matrix shape. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- SPDX-License-Identifier: MIT -->
<!-- Copyright (C) 2022 Xilinx, Inc. -->
<!-- Copyright (C) 2022-2024 Advanced Micro Devices, Inc. -->
<!-- HTML footer for doxygen 1.9.0-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">UG1529 &copy; 2024 Advanced Micro Devices, Inc. All rights reserved.</li>
  </ul>
</div>
</body>
</html>
